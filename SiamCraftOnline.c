//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2016 Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct FILETIME {
    int32_t e0;
    int32_t e1;
};

struct PROCESS_INFORMATION {
    int32_t * e0;
    int32_t * e1;
    int32_t e2;
    int32_t e3;
};

struct SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct STARTUPINFO {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct struct_0 {
    int32_t e0;
    int32_t e1[24];
};

struct struct__IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct struct__IO_marker * e12;
    struct struct__IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct struct__IO_marker {
    struct struct__IO_marker * e0;
    struct struct__IO_FILE * e1;
    int32_t e2;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401000(int32_t ** a1);
int32_t function_401150(int32_t a1, int32_t a2);
void function_4013a1(void);
int32_t function_4013b0(struct struct__IO_FILE * a1, char * a2, int32_t * a3, char * a4);
int32_t function_401ae0(void);
int32_t function_401b00(void);
int32_t function_401b7d(int32_t a1);
int32_t function_401b90(char * lpText, char * a2);
int32_t function_401bea(int32_t a1);
int32_t function_401bf0(void);
int32_t function_401e10(char * a1, char * a2);
int32_t function_401eb7(int32_t a1);
int32_t function_401ec0(uint16_t lpName);
int32_t function_401fa0(uint16_t lpName);
int32_t function_402060(int32_t * a1, int32_t * a2);
int32_t function_402240(char * str, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_402280(struct struct__IO_FILE * a1, char * str2, char * a3);
int32_t function_402430(struct struct__IO_FILE * a1, char * a2, char * a3);
int32_t function_402640(char * a1, char * a2);
int32_t function_402910(char * str, char * str2, char * a3);
int32_t function_402950(struct struct__IO_FILE * str2);
int32_t function_402a30(int32_t * a1, char * a2, int32_t * str6, char * n2);
int32_t function_402cd0(int32_t * a1, char * a2, int32_t lpName, int32_t a4, int32_t a5, char * str3);
int32_t function_402ff6(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4030ba(int32_t a1);
int32_t function_4030c0(struct struct__IO_FILE * a1, struct struct__IO_FILE * a2, char * a3, char * a4);
int32_t function_404760(void);
int32_t function_4047a0(struct struct__IO_FILE * a1, char * a2, char * a3, struct STARTUPINFO * a4, struct PROCESS_INFORMATION * a5);
int32_t function_404940(int32_t a1);
int32_t function_404a60(void);
int32_t function_404a90(void);
int32_t function_404aa0(void);
int32_t function_404ad0(int32_t a1);
int32_t function_404b30(void);
int32_t function_404ba0(int32_t a1);
int32_t function_404bd0(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4);
int32_t unknown_410290(void);
int32_t unknown_4102c4(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0; // esp
struct struct_0 g9; // 0x404f9c
int32_t g10 = 0x4000; // 0x4050a0
int32_t g11 = 0x404fa4; // 0x4050b0
char * g12; // 0x407020
char * g13; // 0x40f020
char * g14; // 0x40f260
char * g15; // 0x40f380
char * g16; // 0x40f4a0
char * g17; // 0x40f520
char * g18; // 0x40f5a0
char * g19; // 0x40f620
char * g20; // 0x40fa20
char * g21; // 0x40fb20
int32_t g22 = 0; // 0x40fba0
char g23 = 0; // 0x40fba1
int32_t g24 = 0; // 0x40fba4
int32_t g25 = 0; // 0x40fba8
int32_t g26 = 0; // 0x40fbc0
int32_t g27 = 0; // 0x40fbd0
int32_t g28 = 0; // 0x40fc20
int32_t g29 = 0; // 0x40fc30
int32_t g30 = 0; // 0x40fc60
int32_t g31 = 0; // 0x40fc70
int32_t g32 = 0; // 0x40fc80
int32_t g33 = 0; // 0x40fc84
int32_t g34 = 0x10644; // 0x4102a8

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x40114f
int32_t function_401000(int32_t ** a1) {
    int32_t v1;
    g2 = &v1;
    g6 = (int32_t)a1;
    g3 = 0;
    g7 = 0;
    uint32_t v2 = *(int32_t *)*(int32_t *)a1; // 0x401015
    g1 = v2;
    void (*prev_sig_handler)(int32_t); // 0x401037
    void (*prev_sig_handler3)(int32_t); // 0x40109b
    if (v2 <= 0xc0000091) {
        // 0x40101e
        if (v2 >= 0xc000008d) {
            // 0x401025
            g7 = 1;
            // branch -> 0x40102a
            // 0x40102a
            g6 = 0;
            prev_sig_handler = signal(SIGFPE, SIG_DFL);
            switch ((int32_t)prev_sig_handler) {
                default: {
                    // 0x401045
                    ((int32_t (*)(int32_t))prev_sig_handler)(8);
                    // branch -> 0x40104e
                    break;
                }
                case 1: {
                    // 0x4010bb
                    signal(SIGFPE, SIG_IGN);
                    if (g7 != 0) {
                        // 0x4010d8
                        function_404a90();
                        // branch -> 0x40104e
                    }
                    break;
                }
                case 0: {
                    // 0x401053
                    return g3;
                }
            }
            // 0x40104e
            g3 = -1;
            // branch -> 0x401053
            // 0x401053
            return g3;
        }
        // 0x401080
        if (v2 == -0x3ffffffb) {
            // 0x4010e2
            g4 = 0;
            void (*prev_sig_handler2)(int32_t) = signal(SIGSEGV, SIG_DFL); // 0x4010ef
            switch ((int32_t)prev_sig_handler2) {
                default: {
                    // 0x401101
                    ((int32_t (*)(int32_t))prev_sig_handler2)(11);
                    // branch -> 0x40104e
                    break;
                }
                case 1: {
                    // 0x401129
                    signal(SIGSEGV, SIG_IGN);
                    // branch -> 0x40104e
                    break;
                }
                case 0: {
                    // 0x401053
                    return g3;
                }
            }
            // 0x40104e
            g3 = -1;
            // branch -> 0x401053
            // 0x401053
            return g3;
        }
        // 0x401087
        // branch -> 0x40108c
        // 0x40108c
        if (v2 != -0x3fffffe3) {
            // 0x401053
            return g3;
        }
        // 0x40108e
        g7 = 0;
        prev_sig_handler3 = signal(SIGILL, SIG_DFL);
        switch ((int32_t)prev_sig_handler3) {
            default: {
                // 0x4010a9
                ((int32_t (*)(int32_t))prev_sig_handler3)(4);
                // branch -> 0x40104e
                break;
            }
            case 1: {
                // 0x40110f
                signal(SIGILL, SIG_IGN);
                // branch -> 0x40104e
                break;
            }
            case 0: {
                // 0x401053
                return g3;
            }
        }
        // 0x40104e
        g3 = -1;
        // branch -> 0x401053
        // 0x401053
        return g3;
    }
    // 0x401061
    if (v2 == -0x3fffff6c) {
        // 0x40102a
        g6 = 0;
        prev_sig_handler = signal(SIGFPE, SIG_DFL);
        switch ((int32_t)prev_sig_handler) {
            default: {
                // 0x401045
                ((int32_t (*)(int32_t))prev_sig_handler)(8);
                // branch -> 0x40104e
                break;
            }
            case 1: {
                // 0x4010bb
                signal(SIGFPE, SIG_IGN);
                if (g7 != 0) {
                    // 0x4010d8
                    function_404a90();
                    // branch -> 0x40104e
                }
                break;
            }
            case 0: {
                // 0x401053
                return g3;
            }
        }
        // 0x40104e
        g3 = -1;
        // branch -> 0x401053
        // 0x401053
        return g3;
    }
    // 0x401068
    if (v2 > 0xc0000094) {
        // 0x4010b4
        // branch -> 0x40108c
        // 0x40108c
        if (v2 != -0x3fffff6a) {
            // 0x401053
            return g3;
        }
        // 0x40108e
        g7 = 0;
        prev_sig_handler3 = signal(SIGILL, SIG_DFL);
        switch ((int32_t)prev_sig_handler3) {
            default: {
                // 0x4010a9
                ((int32_t (*)(int32_t))prev_sig_handler3)(4);
                // branch -> 0x40104e
                break;
            }
            case 1: {
                // 0x40110f
                signal(SIGILL, SIG_IGN);
                // branch -> 0x40104e
                break;
            }
            case 0: {
                // 0x401053
                return g3;
            }
        }
        // 0x40104e
        g3 = -1;
        // branch -> 0x401053
        // 0x401053
        return g3;
    }
    // 0x40106a
    if (v2 != -0x3fffff6d) {
        // 0x401071
        return 0;
    }
    // 0x401025
    g7 = 1;
    // branch -> 0x40102a
    // 0x40102a
    g6 = 0;
    prev_sig_handler = signal(SIGFPE, SIG_DFL);
    switch ((int32_t)prev_sig_handler) {
        default: {
            // 0x401045
            ((int32_t (*)(int32_t))prev_sig_handler)(8);
            // branch -> 0x40104e
            break;
        }
        case 1: {
            // 0x4010bb
            signal(SIGFPE, SIG_IGN);
            if (g7 != 0) {
                // 0x4010d8
                function_404a90();
                // branch -> 0x40104e
            }
            break;
        }
        case 0: {
            // 0x401053
            return g3;
        }
    }
    // 0x40104e
    g3 = -1;
    // branch -> 0x401053
    // 0x401053
    return g3;
}

// Address range: 0x401150 - 0x40128f
int32_t function_401150(int32_t a1, int32_t a2) {
    // 0x401150
    SetUnhandledExceptionFilter((int32_t)function_401000);
    function_404a90();
    __getmainargs();
    int32_t * v1; // 0x401200
    int32_t v2; // 0x401205
    if (g26 == 0) {
        // 0x401200
        v1 = __p__fmode();
        v2 = g10;
        g3 = v2;
        *v1 = v2;
        function_404a60();
        __p__environ();
        abort();
        // UNREACHABLE
    }
    // 0x4011a8
    g10 = g26;
    int32_t v3; // 0x4011da
    if (g34 == 0) {
        // 0x4011a8
        // branch -> 0x4011e0
        // 0x4011e0
        _setmode(*(int32_t *)48, g26);
        v3 = g34;
        if (v3 == -64) {
            // 0x401200
            v1 = __p__fmode();
            v2 = g10;
            g3 = v2;
            *v1 = v2;
            function_404a60();
            __p__environ();
            abort();
            // UNREACHABLE
        }
        // 0x4011e5
        _setmode(*(int32_t *)(v3 + 80), g26);
        // branch -> 0x401200
        // 0x401200
        v1 = __p__fmode();
        v2 = g10;
        g3 = v2;
        *v1 = v2;
        function_404a60();
        __p__environ();
        abort();
        // UNREACHABLE
    }
    // 0x4011bb
    _setmode(*(int32_t *)(g34 + 16), g26);
    if (g34 != -32) {
        // 0x4011bb
        // branch -> 0x4011e0
        // 0x4011e0
        _setmode(*(int32_t *)(g34 + 48), g26);
        v3 = g34;
        if (v3 == -64) {
            // 0x401200
            v1 = __p__fmode();
            v2 = g10;
            g3 = v2;
            *v1 = v2;
            function_404a60();
            __p__environ();
            abort();
            // UNREACHABLE
        }
    } else {
        v3 = -32;
    }
    // 0x4011e5
    _setmode(*(int32_t *)(v3 + 80), g26);
    // branch -> 0x401200
    // 0x401200
    v1 = __p__fmode();
    v2 = g10;
    g3 = v2;
    *v1 = v2;
    function_404a60();
    __p__environ();
    abort();
    // UNREACHABLE
}

// Address range: 0x401290 - 0x4013a0
int32_t entry_point(int32_t a1, int32_t a2, int32_t a3) {
    __set_app_type(2);
    int32_t v1;
    int32_t v2;
    function_401150(v2, v1);
    unknown_4102c4();
    _onexit((int32_t (*)())(int32_t)&v1);
    int32_t v3;
    int32_t str = &v3; // edi
    memset((char *)&v3, 0, 128);
    if (function_401e10((char *)24, (char *)str) == 0) {
        // 0x40138d
        return 0;
    }
    int32_t * v4 = FindWindowExA(NULL, NULL, NULL, NULL); // 0x40132a
    int32_t hWnd = (int32_t)v4; // 0x40132a_12
    if (v4 == NULL) {
        // 0x40138d
        return 0;
    }
    // 0x401338
    int32_t v5;
    int32_t lpString = &v5; // 0x40133e_0
    // branch -> 0x401340
    while (true) {
        // 0x401340
        GetWindowTextA((int32_t *)hWnd, (char *)lpString, 127);
        int32_t hWndChildAfter = hWnd; // 0x401368
        if (strstr((char *)lpString, (char *)str) != NULL) {
            // 0x401397
            return hWndChildAfter;
        }
        int32_t * v6 = FindWindowExA(NULL, (int32_t *)hWndChildAfter, NULL, NULL); // 0x40137f
        if (v6 == NULL) {
            // 0x40138d
            return 0;
        }
        // 0x401368
        hWnd = (int32_t)v6;
        // branch -> 0x401340
    }
}

// Address range: 0x4013a1 - 0x4013af
void function_4013a1(void) {
    // 0x4013a1
    function_4013b0(NULL, NULL, NULL, NULL);
}

// Address range: 0x4013b0 - 0x401adf
int32_t function_4013b0(struct struct__IO_FILE * a1, char * a2, int32_t * a3, char * a4) {
    // 0x4013b0
    g7 = (int32_t)a3;
    int32_t * v1;
    int32_t * v2;
    char * v3;
    function_4030c0((struct struct__IO_FILE *)a3, (struct struct__IO_FILE *)v3, (char *)v2, (char *)v1);
    function_401bf0();
    return 1;
}

// Address range: 0x401ae0 - 0x401aff
int32_t function_401ae0(void) {
    // 0x401ae0
    if (g28 == 0) {
        // 0x401aef
        return 0;
    }
    // 0x401af1
    return fclose((struct struct__IO_FILE *)g28);
}

// Address range: 0x401b00 - 0x401b7c
int32_t function_401b00(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    struct struct__IO_FILE * v2 = (struct struct__IO_FILE *)"kernel32";
    int32_t * moduleHandle = GetModuleHandleA("kernel32"); // 0x401b0e
    g4 = 0x40606b;
    v2 = (struct struct__IO_FILE *)moduleHandle;
    int32_t (*func)() = GetProcAddress(moduleHandle, "IsWow64Process"); // 0x401b22
    g8 = (int32_t)&v2;
    char * format = "IsWow64Process"; // 0x401b732
    if (func != NULL) {
        int32_t * processHandle = GetCurrentProcess(); // 0x401b30
        v2 = (struct struct__IO_FILE *)processHandle;
        g6 = 0x40fba4;
        ((int32_t (*)(int32_t, int32_t))func)((int32_t)processHandle, g24);
        format = (char *)0x40fba4;
        // branch -> 0x401b46
    }
    // 0x401b46
    int32_t * chars_printed; // 0x401b7c_11
    if (g28 != 0) {
        struct struct__IO_FILE * stream = g24 == 0 ? (struct struct__IO_FILE *)0x40607e : (struct struct__IO_FILE *)0x40607a; // 0x401b63
        v2 = stream;
        chars_printed = (int32_t *)fprintf(stream, format);
        // branch -> 0x401b78
    } else {
        chars_printed = (int32_t *)g28;
    }
    // 0x401b78
    return (int32_t)chars_printed;
}

// Address range: 0x401b7d - 0x401b8f
int32_t function_401b7d(int32_t a1) {
    // 0x401b7d
    g25 = 1;
    return 1;
}

// Address range: 0x401b90 - 0x401be9
int32_t function_401b90(char * lpText, char * a2) {
    int32_t hWnd;
    if (g25 == 0) {
        // 0x401bc0
        hWnd = 0;
        return MessageBoxA(&hWnd, lpText, "Launch4j", 0);
    }
    // 0x401ba3
    hWnd = (int32_t)"%s: %s\n";
    return printf("%s: %s\n", "Launch4j", lpText);
}

// Address range: 0x401bea - 0x401bef
int32_t function_401bea(int32_t a1) {
    // 0x401bea
    return g5;
}

// Address range: 0x401bf0 - 0x401e0f
int32_t function_401bf0(void) {
    int32_t errorCode = GetLastError(); // 0x401bf6
    int32_t v1;
    struct struct__IO_FILE * lpBuffer;
    int32_t stream; // 0x401c43
    int32_t file; // 0x401c86
    char * v2; // 0x401c3a_0
    if (errorCode == 0) {
        // 0x401c05
        if (g25 == 0) {
            // 0x401c13
            g1 = 0x405010;
            MessageBoxA(NULL, g19, "Launch4j", 0);
            // branch -> 0x401c3a
        } else {
            // 0x401c91
            g1 = 0x405010;
            printf("%s: %s\n", "Launch4j", g19);
            // branch -> 0x401c3a
        }
        // 0x401c3a
        v2 = g20;
        if ((int32_t)v2 % 256 != 0) {
            // 0x401c43
            stream = g28;
            if (stream != 0) {
                // 0x401dc0
                fprintf((struct struct__IO_FILE *)stream, "Open URL:\t%s\n", v2);
                // branch -> 0x401c50
            }
            // 0x401c50
            v1 = 1;
            g1 = 0x406095;
            char * v3;
            ShellExecuteA(NULL, (char *)&v1, v3, NULL, NULL, (int32_t)lpBuffer);
            // branch -> 0x401c86
        }
        // 0x401c86
        file = g28;
        if (file == 0) {
            // 0x401c8f
            return 0;
        }
        // 0x401cb1
        return fclose((struct struct__IO_FILE *)file);
    }
    // 0x401cc0
    v1 = 0;
    int32_t lpSource;
    FormatMessageA(0x1300, (char *)&lpSource, errorCode, 1024, (char *)&lpBuffer, 0, NULL);
    if (g28 != 0) {
        // 0x401da3
        fprintf((struct struct__IO_FILE *)g28, "Error:\t\t%s\n", lpBuffer);
        // branch -> 0x401d03
    }
    int32_t v4 = 0x40f620; // 0x401d10
    int32_t v5 = *(int32_t *)v4; // 0x401d10
    int32_t v6 = v4 + 4; // 0x401d12
    int32_t v7 = v5 - 0x1010101 & -1 - v5; // 0x401d1d
    uint32_t v8 = v7 & -0x7f7f7f80; // 0x401d21
    // branch -> 0x401d10
    while (v7 == -0x7f7f7f80) {
        // 0x401d10
        v4 = v6;
        v5 = *(int32_t *)v4;
        v6 = v4 + 4;
        v7 = v5 - 0x1010101 & -1 - v5;
        v8 = v7 & -0x7f7f7f80;
        // continue -> 0x401d10
    }
    int32_t v9 = v6; // 0x401d38
    char v10 = v8;
    if (v7 == 0x8080) {
        // 0x401d30
        v9 = v4 + 6;
        v10 = v8 / 0x10000;
        // branch -> 0x401d36
    }
    int32_t v11 = v9 - 3 + (int32_t)(2 * v10 < v10); // 0x401d3f
    *(int16_t *)v11 = 2570;
    *(char *)(v11 + 2) = 0;
    strcat(g19, (char *)lpBuffer);
    if (g25 == 0) {
        // 0x401ddf
        g1 = 0;
        MessageBoxA(NULL, g19, "Launch4j", 0);
        // branch -> 0x401d90
    } else {
        // 0x401d72
        g1 = 0x40f620;
        printf("%s: %s\n", "Launch4j", g19);
        // branch -> 0x401d90
    }
    // 0x401d90
    LocalFree(&lpBuffer->e0);
    // branch -> 0x401c3a
    // 0x401c3a
    v2 = g20;
    if ((int32_t)v2 % 256 != 0) {
        // 0x401c43
        stream = g28;
        if (stream != 0) {
            // 0x401dc0
            fprintf((struct struct__IO_FILE *)stream, "Open URL:\t%s\n", v2);
            // branch -> 0x401c50
        }
        // 0x401c50
        v1 = 1;
        g1 = 0x406095;
        ShellExecuteA(NULL, (char *)&v1, NULL, NULL, NULL, (int32_t)lpBuffer);
        // branch -> 0x401c86
    }
    // 0x401c86
    file = g28;
    if (file == 0) {
        // 0x401c8f
        return 0;
    }
    // 0x401cb1
    return fclose((struct struct__IO_FILE *)file);
}

// Address range: 0x401e10 - 0x401eb6
int32_t function_401e10(char * a1, char * a2) {
    int32_t v1 = g3; // 0x401e18
    g3 = (int32_t)*a2;
    int32_t * hResInfo = FindResourceExA((int32_t *)g31, (char *)10, (char *)((int32_t)a1 % 0x10000), 1024); // 0x401e3c
    if (hResInfo == NULL) {
        // 0x401e96
        abort();
        // UNREACHABLE
    }
    int32_t * hResData = LoadResource((int32_t *)g31, hResInfo); // 0x401e55
    if (hResData == NULL) {
        // 0x401eb0
        g3 = v1;
        return 0;
    }
    char * v2 = LockResource(hResData); // 0x401e64
    if (v2 == NULL) {
        // 0x401eb0
        g3 = v1;
        return 0;
    }
    int32_t v3 = 0; // bp+227
    int32_t v4 = ((int32_t *)v2)[v3]; // 0x401e80
    a2[v3] = v4;
    int32_t v5 = 1; // 0x401e87
    // branch -> 0x401e80
    while (v4 != 0) {
        // 0x401e80
        v3 = v5;
        v4 = ((int32_t *)v2)[v3];
        a2[v3] = v4;
        v5++;
        // continue -> 0x401e80
    }
    // 0x401e8c
    g3 = v1;
    return 1;
}

// Address range: 0x401eb7 - 0x401ebf
int32_t function_401eb7(int32_t a1) {
    // 0x401eb7
    return g7;
}

// Address range: 0x401ec0 - 0x401f9f
int32_t function_401ec0(uint16_t lpName) {
    char * str;
    memset((char *)&str, 0, 5);
    int32_t * hResInfo = FindResourceExA((int32_t *)g31, (char *)10, (char *)(int32_t)lpName, 1024); // 0x401efb
    if (hResInfo == NULL) {
        // 0x401f69
        abort();
        // UNREACHABLE
    }
    int32_t * hResData = LoadResource((int32_t *)g31, hResInfo); // 0x401f14
    if (hResData == NULL) {
        // 0x401f4c
        return strncmp((char *)&str, "true", 5) % 2 == 0;
    }
    char * v1 = LockResource(hResData); // 0x401f23
    if (v1 == NULL) {
        // 0x401f4c
        return strncmp((char *)&str, "true", 5) % 2 == 0;
    }
    int32_t v2 = 0; // bp+232
    char v3 = v1[v2]; // 0x401f40
    str[v2] = v3;
    int32_t v4 = 1; // 0x401f47
    // branch -> 0x401f40
    while ((int32_t)v3 != 0) {
        // 0x401f40
        v2 = v4;
        v3 = v1[v2];
        str[v2] = v3;
        v4++;
        // continue -> 0x401f40
    }
    // 0x401f4c
    return strncmp((char *)&str, "true", 5) % 2 == 0;
}

// Address range: 0x401fa0 - 0x40205f
int32_t function_401fa0(uint16_t lpName) {
    int32_t v1;
    memset((char *)&v1, 0, 5);
    int32_t str = &v1; // edi
    int32_t * hResInfo = FindResourceExA((int32_t *)g31, (char *)10, (char *)(int32_t)lpName, 1024); // 0x401fda
    if (hResInfo == NULL) {
        // 0x402039
        abort();
        // UNREACHABLE
    }
    int32_t * hResData = LoadResource((int32_t *)g31, hResInfo); // 0x401ff3
    if (hResData == NULL) {
        // 0x40202c
        return atoi((char *)str);
    }
    char * v2 = LockResource(hResData); // 0x402002
    if (v2 == NULL) {
        // 0x40202c
        return atoi((char *)str);
    }
    int32_t v3 = 0; // bp+237
    unsigned char v4 = v2[v3]; // 0x402020
    *(char *)(str + v3) = v4;
    int32_t v5 = 1; // 0x402027
    // branch -> 0x402020
    while ((int32_t)v4 != 0) {
        // 0x402020
        v3 = v5;
        v4 = v2[v3];
        *(char *)(str + v3) = v4;
        v5++;
        // continue -> 0x402020
    }
    // 0x40202c
    return atoi((char *)str);
}

// Address range: 0x402060 - 0x40223f
int32_t function_402060(int32_t * a1, int32_t * a2) {
    int32_t v1 = -0x80000000; // esi
    int32_t str = *a1; // 0x402073
    int32_t str3 = str; // ebx
    int32_t str2 = str3; // 0x402082
    int32_t hKey2; // 0x402183
    int32_t hKey; // 0x402152
    int32_t hKey4; // 0x4021d0
    int32_t * phkResult;
    int32_t lpSubKey; // edi
    char * found_char_pos; // 0x402118
    int32_t v2; // 0x402183
    int32_t v3; // 0x4021d0
    int32_t lpReserved;
    int32_t lpcbData;
    int32_t * hKey3;
    int32_t * lpType;
    int32_t * v4; // bp-28
    int32_t lpData; // 0x40216a
    if ((int32_t)strstr((char *)str, "HKEY_CLASSES_ROOT") == str2) {
        // 0x4020f8
        lpSubKey = (int32_t)strchr((char *)str2, 92) + 1;
        found_char_pos = strrchr((char *)str3, 92);
        str3 = (int32_t)found_char_pos + 1;
        *found_char_pos = 0;
        v4 = NULL;
        if (g24 == 0) {
            // 0x4020f8
            phkResult = (int32_t *)&hKey3;
            // branch -> 0x402135
            // 0x402135
            hKey = *(int32_t *)v1;
            if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                // 0x4021a4
                *(char *)(str3 - 1) = 92;
                return *v4;
            }
            // 0x40215e
            lpData = *a2;
            hKey2 = *(int32_t *)*hKey3;
            v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
            RegCloseKey((int32_t *)*hKey3);
            // branch -> 0x4021a4
            // 0x4021a4
            *(char *)(str3 - 1) = 92;
            return *(int32_t *)(int32_t)(v2 == 0);
        }
        // 0x4021b3
        hKey4 = *(int32_t *)v1;
        v3 = RegOpenKeyExA(hKey4, (char *)lpSubKey, 0, 0x20119, (int32_t *)&hKey3);
        if (v3 == 0) {
            // 0x40215e
            lpData = *a2;
            hKey2 = *(int32_t *)*hKey3;
            v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
            RegCloseKey((int32_t *)*hKey3);
            // branch -> 0x4021a4
            // 0x4021a4
            *(char *)(str3 - 1) = 92;
            return *(int32_t *)(int32_t)(v2 == 0);
        }
        phkResult = (int32_t *)&hKey3;
        // 0x402135
        hKey = *(int32_t *)v1;
        if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
            // 0x4021a4
            *(char *)(str3 - 1) = 92;
            return *v4;
        }
        // 0x40215e
        lpData = *a2;
        hKey2 = *(int32_t *)*hKey3;
        v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
        RegCloseKey((int32_t *)*hKey3);
        // branch -> 0x4021a4
        // 0x4021a4
        *(char *)(str3 - 1) = 92;
        return *(int32_t *)(int32_t)(v2 == 0);
    }
    // 0x402086
    v1 = -0x7fffffff;
    int32_t str4 = str3; // 0x40209c
    if ((int32_t)strstr((char *)str2, "HKEY_CURRENT_USER") == str4) {
        // 0x4020f8
        lpSubKey = (int32_t)strchr((char *)str4, 92) + 1;
        found_char_pos = strrchr((char *)str3, 92);
        str3 = (int32_t)found_char_pos + 1;
        *found_char_pos = 0;
        v4 = NULL;
        if (g24 == 0) {
            // 0x4020f8
            phkResult = (int32_t *)&hKey3;
            // branch -> 0x402135
            // 0x402135
            hKey = *(int32_t *)v1;
            if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                // 0x4021a4
                *(char *)(str3 - 1) = 92;
                return *v4;
            }
        } else {
            // 0x4021b3
            hKey4 = *(int32_t *)v1;
            v3 = RegOpenKeyExA(hKey4, (char *)lpSubKey, 0, 0x20119, (int32_t *)&hKey3);
            if (v3 != 0) {
                phkResult = (int32_t *)&hKey3;
                // 0x402135
                hKey = *(int32_t *)v1;
                if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                    // 0x4021a4
                    *(char *)(str3 - 1) = 92;
                    return *v4;
                }
            }
        }
        // 0x40215e
        lpData = *a2;
        hKey2 = *(int32_t *)*hKey3;
        v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
        RegCloseKey((int32_t *)*hKey3);
        // branch -> 0x4021a4
        // 0x4021a4
        *(char *)(str3 - 1) = 92;
        return *(int32_t *)(int32_t)(v2 == 0);
    }
    // 0x4020a0
    v1 = -0x7ffffffe;
    int32_t str5 = str3; // 0x4020b6
    if ((int32_t)strstr((char *)str4, "HKEY_LOCAL_MACHINE") == str5) {
        // 0x4020f8
        lpSubKey = (int32_t)strchr((char *)str5, 92) + 1;
        found_char_pos = strrchr((char *)str3, 92);
        str3 = (int32_t)found_char_pos + 1;
        *found_char_pos = 0;
        v4 = NULL;
        if (g24 == 0) {
            // 0x4020f8
            phkResult = (int32_t *)&hKey3;
            // branch -> 0x402135
            // 0x402135
            hKey = *(int32_t *)v1;
            if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                // 0x4021a4
                *(char *)(str3 - 1) = 92;
                return *v4;
            }
        } else {
            // 0x4021b3
            hKey4 = *(int32_t *)v1;
            v3 = RegOpenKeyExA(hKey4, (char *)lpSubKey, 0, 0x20119, (int32_t *)&hKey3);
            if (v3 != 0) {
                phkResult = (int32_t *)&hKey3;
                // 0x402135
                hKey = *(int32_t *)v1;
                if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                    // 0x4021a4
                    *(char *)(str3 - 1) = 92;
                    return *v4;
                }
            }
        }
        // 0x40215e
        lpData = *a2;
        hKey2 = *(int32_t *)*hKey3;
        v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
        RegCloseKey((int32_t *)*hKey3);
        // branch -> 0x4021a4
        // 0x4021a4
        *(char *)(str3 - 1) = 92;
        return *(int32_t *)(int32_t)(v2 == 0);
    }
    // 0x4020ba
    v1 = -0x7ffffffd;
    int32_t str6 = str3; // 0x4020d0
    if ((int32_t)strstr((char *)str5, "HKEY_USERS") == str6) {
        // 0x4020f8
        lpSubKey = (int32_t)strchr((char *)str6, 92) + 1;
        found_char_pos = strrchr((char *)str3, 92);
        str3 = (int32_t)found_char_pos + 1;
        *found_char_pos = 0;
        v4 = NULL;
        if (g24 == 0) {
            // 0x4020f8
            phkResult = (int32_t *)&hKey3;
            // branch -> 0x402135
            // 0x402135
            hKey = *(int32_t *)v1;
            if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                // 0x4021a4
                *(char *)(str3 - 1) = 92;
                return *v4;
            }
        } else {
            // 0x4021b3
            hKey4 = *(int32_t *)v1;
            v3 = RegOpenKeyExA(hKey4, (char *)lpSubKey, 0, 0x20119, (int32_t *)&hKey3);
            if (v3 != 0) {
                phkResult = (int32_t *)&hKey3;
                // 0x402135
                hKey = *(int32_t *)v1;
                if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                    // 0x4021a4
                    *(char *)(str3 - 1) = 92;
                    return *v4;
                }
            }
        }
        // 0x40215e
        lpData = *a2;
        hKey2 = *(int32_t *)*hKey3;
        v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
        RegCloseKey((int32_t *)*hKey3);
        // branch -> 0x4021a4
        // 0x4021a4
        *(char *)(str3 - 1) = 92;
        return *(int32_t *)(int32_t)(v2 == 0);
    }
    // 0x4020d4
    v1 = -0x7ffffffb;
    int32_t str7 = str3; // 0x4020ea
    if ((int32_t)strstr((char *)str6, "HKEY_CURRENT_CONFIG") != str7) {
        // 0x4020ee
        return 0;
    }
    // 0x4020f8
    lpSubKey = (int32_t)strchr((char *)str7, 92) + 1;
    found_char_pos = strrchr((char *)str3, 92);
    str3 = (int32_t)found_char_pos + 1;
    *found_char_pos = 0;
    v4 = NULL;
    if (g24 == 0) {
        // 0x4020f8
        phkResult = (int32_t *)&hKey3;
        // branch -> 0x402135
        // 0x402135
        hKey = *(int32_t *)v1;
        if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
            // 0x4021a4
            *(char *)(str3 - 1) = 92;
            return *v4;
        }
    } else {
        // 0x4021b3
        hKey4 = *(int32_t *)v1;
        v3 = RegOpenKeyExA(hKey4, (char *)lpSubKey, 0, 0x20119, (int32_t *)&hKey3);
        if (v3 != 0) {
            phkResult = (int32_t *)&hKey3;
            // 0x402135
            hKey = *(int32_t *)v1;
            if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0x20019, phkResult) != 0) {
                // 0x4021a4
                *(char *)(str3 - 1) = 92;
                return *v4;
            }
        }
    }
    // 0x40215e
    lpData = *a2;
    hKey2 = *(int32_t *)*hKey3;
    v2 = RegQueryValueExA(hKey2, (char *)str3, &lpReserved, (int32_t *)&lpType, (char *)lpData, &lpcbData);
    RegCloseKey((int32_t *)*hKey3);
    // branch -> 0x4021a4
    // 0x4021a4
    *(char *)(str3 - 1) = 92;
    return *(int32_t *)(int32_t)(v2 == 0);
}

// Address range: 0x402240 - 0x40227f
int32_t function_402240(char * str, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)str; // ebx
    int32_t len = strlen(str); // 0x402255
    if (*(char *)(len - 1 + v1) != 92) {
        // 0x402261
        *(int16_t *)(v1 + len) = 92;
        // branch -> 0x402267
    }
    // 0x402267
    char * str2;
    strcat((char *)g2, str2);
    return g1;
}

// Address range: 0x402280 - 0x40242f
int32_t function_402280(struct struct__IO_FILE * a1, char * str2, char * a3) {
    int32_t v1; // bp-1064
    int32_t lpcchName = &v1; // edi
    char * v2;
    int32_t v3 = (int32_t)&v2; // 0x402298_3
    v1 = 1024;
    int32_t v4;
    int32_t lpName = &v4; // ebx
    int32_t v5 = 0; // esi
    memset((char *)&v4, 0, 1024);
    // branch -> 0x4022fd
    while (true) {
        int32_t dwIndex = v5; // 0x4022fd
        v5 = dwIndex + 1;
        v2 = (char *)a1;
        int32_t lpReserved;
        int32_t lpftLastWriteTime;
        int32_t result = RegEnumKeyExA(&a1->e0, dwIndex, (char *)lpName, (int32_t *)lpcchName, &lpReserved, NULL, NULL, (struct FILETIME *)&lpftLastWriteTime); // 0x40232f
        if (result != 0) {
            // 0x402427
            return result;
        }
        char * str = (char *)lpName; // 0x40234b_5
        int32_t stream; // 0x4022e5
        if (strcmp(str, g18) >= 0) {
            // 0x402354
            if ((int32_t)g17 % 256 != 0) {
                // 0x4022d0
                *(int32_t *)v3 = lpName;
                *(int32_t *)(v3 + 4) = 0x40f520;
                *(int32_t *)(v3 - 4) = 0x4022e1;
                if (strcmp(str, (char *)0x40f5a0) >= 1) {
                  lab_0x4022e5:
                    // 0x4022e5
                    stream = g28;
                    if (stream != 0) {
                      lab_0x402406:
                        // 0x402406
                        v2 = (char *)stream;
                        fprintf((struct struct__IO_FILE *)stream, "Ignore:\t\t%s\\%s\n", str2, (int32_t *)lpName);
                        // branch -> 0x4022f2
                    }
                  lab_0x4022f2_3:
                    // 0x4022f2
                    v1 = 1024;
                    // branch -> 0x4022fd
                    continue;
                }
            }
            // 0x402361
            if (strcmp((char *)lpName, g16) < 1) {
                goto lab_0x4022e5;
            }
            // 0x40237a
            v2 = (char *)0x40f4a0;
            strcpy(g16, (char *)lpName);
            v2 = (char *)0x40f380;
            strcpy(g15, str2);
            v2 = (char *)0x40f380;
            int32_t len = strlen(g15); // 0x4023a4
            if (*(char *)(len + 0x40f37f) != 92) {
                // 0x4023b2
                *(int16_t *)(len + 0x40f380) = 92;
                // branch -> 0x4023be
            }
            // 0x4023be
            v2 = (char *)0x40f380;
            strcat(g15, (char *)lpName);
            g22 = (int32_t)a3;
            if (g28 == 0) {
                goto lab_0x4022f2_3;
            }
            // 0x4023e7
            v2 = (char *)g28;
            fprintf((struct struct__IO_FILE *)g28, "Match:\t\t%s\n", g15);
            // branch -> 0x4022f2
            goto lab_0x4022f2_3;
        }
        // 0x4022e5
        stream = g28;
        if (stream == 0) {
            goto lab_0x4022f2_3;
        }
        goto lab_0x402406;
    }
}

// Address range: 0x402430 - 0x40263f
int32_t function_402430(struct struct__IO_FILE * a1, char * a2, char * a3) {
    int32_t v1 = g3; // 0x402436
    int32_t lpSubKey = (int32_t)a1; // 0x402439
    g3 = lpSubKey;
    int32_t v2 = g5; // 0x40243c
    g5 = (int32_t)a2;
    int32_t v3 = g7; // 0x402442
    int32_t items_written;
    int32_t result; // 0x402485
    int32_t result2; // 0x402581
    int32_t * hKey;
    int32_t v4;
    int32_t stream2; // 0x40245a
    int32_t stream; // 0x402534
    int32_t v5; // 0x40256c
    int32_t * v6; // 0x402570_0
    if (g28 == 0) {
        int32_t phkResult = (int32_t)&hKey; // 0x402453_0
        g7 = phkResult;
        if (g24 != 0) {
            // 0x4024d0
            if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, (char *)lpSubKey, 0, 0x20119, (int32_t *)phkResult) == 0) {
                // 0x4024fe
                function_402280((struct struct__IO_FILE *)hKey, (char *)g3, (char *)(g5 | 256));
                RegCloseKey(hKey);
                if (g23 != 1) {
                    // 0x402534
                    stream = g28;
                    if (stream != 0) {
                        // 0x402541
                        items_written = fwrite("Using 64-bit runtime.\n", 1, 22, (struct struct__IO_FILE *)stream);
                        // branch -> 0x402495
                    } else {
                        items_written = 0;
                    }
                    // 0x402495
                    g3 = v1;
                    g7 = v3;
                    g5 = v2;
                    g2 = v4;
                    return items_written;
                }
                // 0x40245a
                stream2 = g28;
                if (stream2 != 0) {
                    // 0x402596
                    fprintf((struct struct__IO_FILE *)stream2, "32-bit search:\t%s...\n", (char *)g3);
                    // branch -> 0x402467
                }
                // 0x402467
                result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, (char *)g3, 0, 0x20019, (int32_t *)g7);
                if (result != 0) {
                    // 0x402495
                    g3 = v1;
                    g7 = v3;
                    g5 = v2;
                    g2 = v4;
                    return result;
                }
                // 0x402568
                v5 = g3;
                v6 = hKey;
                g3 = (int32_t)v6;
                function_402280((struct struct__IO_FILE *)v6, (char *)v5, (char *)g5);
                result2 = RegCloseKey(hKey);
                g3 = v1;
                g7 = v3;
                g5 = v2;
                g2 = v4;
                return result2;
            }
        }
        // 0x40245a
        stream2 = g28;
        if (stream2 != 0) {
            // 0x402596
            fprintf((struct struct__IO_FILE *)stream2, "32-bit search:\t%s...\n", (char *)g3);
            // branch -> 0x402467
        }
        // 0x402467
        result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, (char *)g3, 0, 0x20019, (int32_t *)g7);
        if (result != 0) {
            // 0x402495
            g3 = v1;
            g7 = v3;
            g5 = v2;
            g2 = v4;
            return result;
        }
        // 0x402568
        v5 = g3;
        v6 = hKey;
        g3 = (int32_t)v6;
        function_402280((struct struct__IO_FILE *)v6, (char *)v5, (char *)g5);
        result2 = RegCloseKey(hKey);
        g3 = v1;
        g7 = v3;
        g5 = v2;
        g2 = v4;
        return result2;
    }
    // 0x4024a2
    g7 = (int32_t)&hKey;
    fprintf((struct struct__IO_FILE *)g28, "64-bit search:\t%s...\n", a1);
    if (g24 != 0) {
        // 0x4024a2
        // branch -> 0x4024d0
        // 0x4024d0
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, (char *)g3, 0, 0x20119, (int32_t *)g7) == 0) {
            // 0x4024fe
            function_402280((struct struct__IO_FILE *)hKey, (char *)g3, (char *)(g5 | 256));
            RegCloseKey(hKey);
            if (g23 != 1) {
                // 0x402534
                stream = g28;
                if (stream != 0) {
                    // 0x402541
                    items_written = fwrite("Using 64-bit runtime.\n", 1, 22, (struct struct__IO_FILE *)stream);
                    // branch -> 0x402495
                } else {
                    items_written = 0;
                }
                // 0x402495
                g3 = v1;
                g7 = v3;
                g5 = v2;
                g2 = v4;
                return items_written;
            }
            // 0x40245a
            stream2 = g28;
            if (stream2 != 0) {
                // 0x402596
                fprintf((struct struct__IO_FILE *)stream2, "32-bit search:\t%s...\n", (char *)g3);
                // branch -> 0x402467
            }
            // 0x402467
            result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, (char *)g3, 0, 0x20019, (int32_t *)g7);
            if (result != 0) {
                // 0x402495
                g3 = v1;
                g7 = v3;
                g5 = v2;
                g2 = v4;
                return result;
            }
            // 0x402568
            v5 = g3;
            v6 = hKey;
            g3 = (int32_t)v6;
            function_402280((struct struct__IO_FILE *)v6, (char *)v5, (char *)g5);
            result2 = RegCloseKey(hKey);
            g3 = v1;
            g7 = v3;
            g5 = v2;
            g2 = v4;
            return result2;
        }
    }
    // 0x40245a
    stream2 = g28;
    if (stream2 != 0) {
        // 0x402596
        fprintf((struct struct__IO_FILE *)stream2, "32-bit search:\t%s...\n", (char *)g3);
        // branch -> 0x402467
    }
    // 0x402467
    result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, (char *)g3, 0, 0x20019, (int32_t *)g7);
    if (result != 0) {
        // 0x402495
        g3 = v1;
        g7 = v3;
        g5 = v2;
        g2 = v4;
        return result;
    }
    // 0x402568
    v5 = g3;
    v6 = hKey;
    g3 = (int32_t)v6;
    function_402280((struct struct__IO_FILE *)v6, (char *)v5, (char *)g5);
    result2 = RegCloseKey(hKey);
    g3 = v1;
    g7 = v3;
    g5 = v2;
    g2 = v4;
    return result2;
}

// Address range: 0x402640 - 0x40290f
int32_t function_402640(char * a1, char * a2) {
    int32_t v1 = (int32_t)a2; // 0x40264c
    g7 = v1;
    g5 = (int32_t)*a1;
    int32_t v2 = v1 - 2; // 0x402652
    g3 = v2;
    int32_t v3; // 0x40281b
    char hKey;
    char hKey2;
    int32_t v4;
    int32_t v5; // 0x402790
    int32_t v6; // 0x4027f8
    int32_t len; // 0x40282c
    int32_t v7;
    char * phkResult;
    int32_t lpcbData;
    int32_t v8;
    int32_t lpReserved;
    int32_t v9; // 0x402690
    int32_t v10; // 0x4026da
    int32_t v11; // 0x402754
    int32_t str; // 0x40283e
    int32_t v12; // 0x402831
    int32_t lpData; // 0x4027df
    int32_t lpType; // 0x4027e3
    unsigned char v13; // 0x402810
    if (v2 > 1) {
        // 0x402700
        function_402430((struct struct__IO_FILE *)"SOFTWARE\\JavaSoft\\Java Runtime Environment", (char *)1, (char *)&lpReserved);
        if (g7 != 0) {
            // 0x40271d
            function_402430((struct struct__IO_FILE *)"SOFTWARE\\JavaSoft\\Java Development Kit", (char *)2, (char *)&lpReserved);
            // branch -> 0x402690
        }
        // 0x402690
        v9 = g22;
        if (v9 == 0) {
            // 0x40269e
            if (g3 > 1) {
                // 0x402737
                function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java2 Runtime Environment", (char *)1, (char *)&lpReserved);
                if (g7 != 0) {
                    // 0x40286d
                    function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java Development Kit", (char *)2, (char *)&lpReserved);
                    // branch -> 0x4026da
                    // 0x4026da
                    v10 = g22;
                    if (v10 == 0) {
                        // 0x4026f0
                        return 0;
                    }
                    // 0x402760
                    lpReserved = 0;
                    hKey = *(char *)-0x7ffffffe;
                    v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v10 & 256 | 0x20019, (int32_t *)&phkResult);
                    if (v5 != 0) {
                        // 0x4026f0
                        return 0;
                    }
                    // 0x4027a0
                    lpReserved = 1024;
                    memset((char *)&v7, 0, 1024);
                    lpcbData = 1024;
                    lpData = &v7;
                    lpType = &v8;
                    lpReserved = 0;
                    hKey2 = *(char *)(int32_t)*phkResult;
                    v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                    if (v6 != 0) {
                        // 0x402887
                        RegCloseKey((int32_t *)(int32_t)*phkResult);
                        // branch -> 0x4026f0
                        // 0x4026f0
                        return 0;
                    }
                    // 0x402808
                    v4 = 0;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3 = 1;
                    // branch -> 0x402810
                    while ((int32_t)v13 != 0) {
                        // 0x402810
                        v4 = v3;
                        v13 = *(char *)(v4 - 1048 + g2);
                        a1[v4] = v13;
                        v3++;
                        // continue -> 0x402810
                    }
                    // 0x402820
                    if ((char)g22 == 2) {
                        // 0x40284f
                        RegCloseKey((int32_t *)(int32_t)*phkResult);
                        return 1;
                    }
                    // 0x402829
                    len = strlen((char *)g5);
                    v12 = g5;
                    if (*(char *)(len - 1 + v12) != 92) {
                        // 0x402838
                        *(int16_t *)(v12 + len) = 92;
                        str = g5;
                        // branch -> 0x40283e
                    } else {
                        str = v12;
                    }
                    // 0x40283e
                    strcat((char *)str, "jre");
                    // branch -> 0x40284f
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
            } else {
                // 0x4026a7
                g3 = 2;
                function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java Development Kit", (char *)2, (char *)&lpReserved);
                if (g7 != 3) {
                    // 0x4026c5
                    g7 = 1;
                    function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java2 Runtime Environment", (char *)1, (char *)&lpReserved);
                    // branch -> 0x4026da
                    // 0x4026da
                    v10 = g22;
                    if (v10 == 0) {
                        // 0x4026f0
                        return 0;
                    }
                    // 0x402760
                    lpReserved = 0;
                    hKey = *(char *)-0x7ffffffe;
                    v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v10 & 256 | 0x20019, (int32_t *)&phkResult);
                    if (v5 != 0) {
                        // 0x4026f0
                        return 0;
                    }
                    // 0x4027a0
                    lpReserved = 1024;
                    memset((char *)&v7, 0, 1024);
                    lpcbData = 1024;
                    lpData = &v7;
                    lpType = &v8;
                    lpReserved = 0;
                    hKey2 = *(char *)(int32_t)*phkResult;
                    v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                    if (v6 != 0) {
                        // 0x402887
                        RegCloseKey((int32_t *)(int32_t)*phkResult);
                        // branch -> 0x4026f0
                        // 0x4026f0
                        return 0;
                    }
                    // 0x402808
                    v4 = 0;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3 = 1;
                    // branch -> 0x402810
                    while ((int32_t)v13 != 0) {
                        // 0x402810
                        v4 = v3;
                        v13 = *(char *)(v4 - 1048 + g2);
                        a1[v4] = v13;
                        v3++;
                        // continue -> 0x402810
                    }
                    // 0x402820
                    if ((char)g22 == 2) {
                        // 0x40284f
                        RegCloseKey((int32_t *)(int32_t)*phkResult);
                        return 1;
                    }
                    // 0x402829
                    len = strlen((char *)g5);
                    v12 = g5;
                    if (*(char *)(len - 1 + v12) != 92) {
                        // 0x402838
                        *(int16_t *)(v12 + len) = 92;
                        str = g5;
                        // branch -> 0x40283e
                    } else {
                        str = v12;
                    }
                    // 0x40283e
                    strcat((char *)str, "jre");
                    // branch -> 0x40284f
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
            }
            // 0x402754
            v11 = g22;
            if (v11 != 0) {
                // 0x402760
                lpReserved = 0;
                hKey = *(char *)-0x7ffffffe;
                v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v11 & 256 | 0x20019, (int32_t *)&phkResult);
                if (v5 == 0) {
                    // 0x4027a0
                    lpReserved = 1024;
                    memset((char *)&v7, 0, 1024);
                    lpcbData = 1024;
                    lpData = &v7;
                    lpType = &v8;
                    lpReserved = 0;
                    hKey2 = *(char *)(int32_t)*phkResult;
                    v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                    if (v6 != 0) {
                        // 0x402887
                        RegCloseKey((int32_t *)(int32_t)*phkResult);
                        // branch -> 0x4026f0
                        // 0x4026f0
                        return 0;
                    }
                    // 0x402808
                    v4 = 0;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3 = 1;
                    // branch -> 0x402810
                    while ((int32_t)v13 != 0) {
                        // 0x402810
                        v4 = v3;
                        v13 = *(char *)(v4 - 1048 + g2);
                        a1[v4] = v13;
                        v3++;
                        // continue -> 0x402810
                    }
                    // 0x402820
                    if ((char)g22 == 2) {
                        // 0x40284f
                        RegCloseKey((int32_t *)(int32_t)*phkResult);
                        return 1;
                    }
                    // 0x402829
                    len = strlen((char *)g5);
                    v12 = g5;
                    if (*(char *)(len - 1 + v12) != 92) {
                        // 0x402838
                        *(int16_t *)(v12 + len) = 92;
                        str = g5;
                        // branch -> 0x40283e
                    } else {
                        str = v12;
                    }
                    // 0x40283e
                    strcat((char *)str, "jre");
                    // branch -> 0x40284f
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
            }
        } else {
            // 0x402760
            lpReserved = 0;
            hKey = *(char *)-0x7ffffffe;
            v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v9 & 256 | 0x20019, (int32_t *)&phkResult);
            if (v5 == 0) {
                // 0x4027a0
                lpReserved = 1024;
                memset((char *)&v7, 0, 1024);
                lpcbData = 1024;
                lpData = &v7;
                lpType = &v8;
                lpReserved = 0;
                hKey2 = *(char *)(int32_t)*phkResult;
                v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                if (v6 != 0) {
                    // 0x402887
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    // branch -> 0x4026f0
                    // 0x4026f0
                    return 0;
                }
                // 0x402808
                v4 = 0;
                v13 = *(char *)(v4 - 1048 + g2);
                a1[v4] = v13;
                v3 = 1;
                // branch -> 0x402810
                while ((int32_t)v13 != 0) {
                    // 0x402810
                    v4 = v3;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3++;
                    // continue -> 0x402810
                }
                // 0x402820
                if ((char)g22 == 2) {
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
                // 0x402829
                len = strlen((char *)g5);
                v12 = g5;
                if (*(char *)(len - 1 + v12) != 92) {
                    // 0x402838
                    *(int16_t *)(v12 + len) = 92;
                    str = g5;
                    // branch -> 0x40283e
                } else {
                    str = v12;
                }
                // 0x40283e
                strcat((char *)str, "jre");
                // branch -> 0x40284f
                // 0x40284f
                RegCloseKey((int32_t *)(int32_t)*phkResult);
                return 1;
            }
        }
        // 0x4026f0
        return 0;
    }
    // 0x40265e
    function_402430((struct struct__IO_FILE *)"SOFTWARE\\JavaSoft\\Java Development Kit", (char *)2, (char *)&lpReserved);
    if (g7 != 3) {
        // 0x402678
        function_402430((struct struct__IO_FILE *)"SOFTWARE\\JavaSoft\\Java Runtime Environment", (char *)1, (char *)&lpReserved);
        // branch -> 0x402690
    }
    // 0x402690
    v9 = g22;
    if (v9 == 0) {
        // 0x40269e
        if (g3 > 1) {
            // 0x402737
            function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java2 Runtime Environment", (char *)1, (char *)&lpReserved);
            if (g7 != 0) {
                // 0x40286d
                function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java Development Kit", (char *)2, (char *)&lpReserved);
                // branch -> 0x4026da
                // 0x4026da
                v10 = g22;
                if (v10 == 0) {
                    // 0x4026f0
                    return 0;
                }
                // 0x402760
                lpReserved = 0;
                hKey = *(char *)-0x7ffffffe;
                v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v10 & 256 | 0x20019, (int32_t *)&phkResult);
                if (v5 != 0) {
                    // 0x4026f0
                    return 0;
                }
                // 0x4027a0
                lpReserved = 1024;
                memset((char *)&v7, 0, 1024);
                lpcbData = 1024;
                lpData = &v7;
                lpType = &v8;
                lpReserved = 0;
                hKey2 = *(char *)(int32_t)*phkResult;
                v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                if (v6 != 0) {
                    // 0x402887
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    // branch -> 0x4026f0
                    // 0x4026f0
                    return 0;
                }
                // 0x402808
                v4 = 0;
                v13 = *(char *)(v4 - 1048 + g2);
                a1[v4] = v13;
                v3 = 1;
                // branch -> 0x402810
                while ((int32_t)v13 != 0) {
                    // 0x402810
                    v4 = v3;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3++;
                    // continue -> 0x402810
                }
                // 0x402820
                if ((char)g22 == 2) {
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
                // 0x402829
                len = strlen((char *)g5);
                v12 = g5;
                if (*(char *)(len - 1 + v12) != 92) {
                    // 0x402838
                    *(int16_t *)(v12 + len) = 92;
                    str = g5;
                    // branch -> 0x40283e
                } else {
                    str = v12;
                }
                // 0x40283e
                strcat((char *)str, "jre");
                // branch -> 0x40284f
                // 0x40284f
                RegCloseKey((int32_t *)(int32_t)*phkResult);
                return 1;
            }
        } else {
            // 0x4026a7
            g3 = 2;
            function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java Development Kit", (char *)2, (char *)&lpReserved);
            if (g7 != 3) {
                // 0x4026c5
                g7 = 1;
                function_402430((struct struct__IO_FILE *)"SOFTWARE\\IBM\\Java2 Runtime Environment", (char *)1, (char *)&lpReserved);
                // branch -> 0x4026da
                // 0x4026da
                v10 = g22;
                if (v10 == 0) {
                    // 0x4026f0
                    return 0;
                }
                // 0x402760
                lpReserved = 0;
                hKey = *(char *)-0x7ffffffe;
                v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v10 & 256 | 0x20019, (int32_t *)&phkResult);
                if (v5 != 0) {
                    // 0x4026f0
                    return 0;
                }
                // 0x4027a0
                lpReserved = 1024;
                memset((char *)&v7, 0, 1024);
                lpcbData = 1024;
                lpData = &v7;
                lpType = &v8;
                lpReserved = 0;
                hKey2 = *(char *)(int32_t)*phkResult;
                v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                if (v6 != 0) {
                    // 0x402887
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    // branch -> 0x4026f0
                    // 0x4026f0
                    return 0;
                }
                // 0x402808
                v4 = 0;
                v13 = *(char *)(v4 - 1048 + g2);
                a1[v4] = v13;
                v3 = 1;
                // branch -> 0x402810
                while ((int32_t)v13 != 0) {
                    // 0x402810
                    v4 = v3;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3++;
                    // continue -> 0x402810
                }
                // 0x402820
                if ((char)g22 == 2) {
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
                // 0x402829
                len = strlen((char *)g5);
                v12 = g5;
                if (*(char *)(len - 1 + v12) != 92) {
                    // 0x402838
                    *(int16_t *)(v12 + len) = 92;
                    str = g5;
                    // branch -> 0x40283e
                } else {
                    str = v12;
                }
                // 0x40283e
                strcat((char *)str, "jre");
                // branch -> 0x40284f
                // 0x40284f
                RegCloseKey((int32_t *)(int32_t)*phkResult);
                return 1;
            }
        }
        // 0x402754
        v11 = g22;
        if (v11 != 0) {
            // 0x402760
            lpReserved = 0;
            hKey = *(char *)-0x7ffffffe;
            v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v11 & 256 | 0x20019, (int32_t *)&phkResult);
            if (v5 == 0) {
                // 0x4027a0
                lpReserved = 1024;
                memset((char *)&v7, 0, 1024);
                lpcbData = 1024;
                lpData = &v7;
                lpType = &v8;
                lpReserved = 0;
                hKey2 = *(char *)(int32_t)*phkResult;
                v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
                if (v6 != 0) {
                    // 0x402887
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    // branch -> 0x4026f0
                    // 0x4026f0
                    return 0;
                }
                // 0x402808
                v4 = 0;
                v13 = *(char *)(v4 - 1048 + g2);
                a1[v4] = v13;
                v3 = 1;
                // branch -> 0x402810
                while ((int32_t)v13 != 0) {
                    // 0x402810
                    v4 = v3;
                    v13 = *(char *)(v4 - 1048 + g2);
                    a1[v4] = v13;
                    v3++;
                    // continue -> 0x402810
                }
                // 0x402820
                if ((char)g22 == 2) {
                    // 0x40284f
                    RegCloseKey((int32_t *)(int32_t)*phkResult);
                    return 1;
                }
                // 0x402829
                len = strlen((char *)g5);
                v12 = g5;
                if (*(char *)(len - 1 + v12) != 92) {
                    // 0x402838
                    *(int16_t *)(v12 + len) = 92;
                    str = g5;
                    // branch -> 0x40283e
                } else {
                    str = v12;
                }
                // 0x40283e
                strcat((char *)str, "jre");
                // branch -> 0x40284f
                // 0x40284f
                RegCloseKey((int32_t *)(int32_t)*phkResult);
                return 1;
            }
        }
    } else {
        // 0x402760
        lpReserved = 0;
        hKey = *(char *)-0x7ffffffe;
        v5 = RegOpenKeyExA((int32_t)hKey, g15, 0, v9 & 256 | 0x20019, (int32_t *)&phkResult);
        if (v5 == 0) {
            // 0x4027a0
            lpReserved = 1024;
            memset((char *)&v7, 0, 1024);
            lpcbData = 1024;
            lpData = &v7;
            lpType = &v8;
            lpReserved = 0;
            hKey2 = *(char *)(int32_t)*phkResult;
            v6 = RegQueryValueExA((int32_t)hKey2, "JavaHome", &lpReserved, (int32_t *)lpType, (char *)lpData, &lpcbData);
            if (v6 != 0) {
                // 0x402887
                RegCloseKey((int32_t *)(int32_t)*phkResult);
                // branch -> 0x4026f0
                // 0x4026f0
                return 0;
            }
            // 0x402808
            v4 = 0;
            v13 = *(char *)(v4 - 1048 + g2);
            a1[v4] = v13;
            v3 = 1;
            // branch -> 0x402810
            while ((int32_t)v13 != 0) {
                // 0x402810
                v4 = v3;
                v13 = *(char *)(v4 - 1048 + g2);
                a1[v4] = v13;
                v3++;
                // continue -> 0x402810
            }
            // 0x402820
            if ((char)g22 == 2) {
                // 0x40284f
                RegCloseKey((int32_t *)(int32_t)*phkResult);
                return 1;
            }
            // 0x402829
            len = strlen((char *)g5);
            v12 = g5;
            if (*(char *)(len - 1 + v12) != 92) {
                // 0x402838
                *(int16_t *)(v12 + len) = 92;
                str = g5;
                // branch -> 0x40283e
            } else {
                str = v12;
            }
            // 0x40283e
            strcat((char *)str, "jre");
            // branch -> 0x40284f
            // 0x40284f
            RegCloseKey((int32_t *)(int32_t)*phkResult);
            return 1;
        }
    }
    // 0x4026f0
    return 0;
}

// Address range: 0x402910 - 0x40294f
int32_t function_402910(char * str, char * str2, char * a3) {
    int32_t str3 = (int32_t)str; // ebx
    strcat(str, str2);
    char * v1; // 0x402944_11
    if (*a3 != 0) {
        int32_t len = strlen((char *)str3); // 0x402934
        *(int16_t *)(str3 + len) = 59;
        v1 = (char *)len;
        // branch -> 0x40293f
    } else {
        v1 = a3;
    }
    // 0x40293f
    return (int32_t)v1;
}

// Address range: 0x402950 - 0x402a2f
int32_t function_402950(struct struct__IO_FILE * str2) {
    int32_t str3 = 0; // ebx
    int32_t v1 = 0; // 0x40296e
    int32_t str;
    if (*(char *)str2 != 0) {
        // 0x4029a6
        str3 = &str;
        strcpy((char *)&str, (char *)str2);
        int32_t len = strlen((char *)str3); // 0x402a08
        int32_t v2 = str3; // 0x402a0d
        char v3 = *(char *)(len - 1 + v2); // 0x402a0d
        int32_t str4;
        if (g25 == 0) {
            // 0x402a05
            if (v3 != 92) {
                // 0x402a14
                *(int16_t *)(v2 + len) = 92;
                str4 = 0x406229;
                // branch -> 0x4029dc
            } else {
                str4 = 0x406229;
            }
        } else {
            // 0x4029c2
            if (v3 != 92) {
                // 0x4029d1
                *(int16_t *)(v2 + len) = 92;
                str4 = 0x40621c;
                // branch -> 0x4029dc
            } else {
                str4 = 0x40621c;
            }
        }
        // 0x4029dc
        strcat((char *)str3, (char *)str4);
        int32_t v4 = stat((char *)str3, &g29); // 0x4029f6
        int32_t v5;
        int32_t v6 = (int32_t)&v5 & -256 | (int32_t)(v4 == 0); // 0x4029fd
        str3 = v6;
        v1 = v6;
        // branch -> 0x402964
    }
    // 0x402964
    if (g28 != 0) {
        int32_t v7 = v1 == 0 ? 0x40623c : 0x406237;
        fprintf((struct struct__IO_FILE *)g28, "Check launcher:\t%s %s\n", &str, &v7);
        // branch -> 0x40299b
    } else {
        str3 = v1;
    }
    // 0x40299b
    return str3;
}

// Address range: 0x402a30 - 0x402ccf
int32_t function_402a30(int32_t * a1, char * a2, int32_t * str6, char * n2) {
    struct struct__IO_FILE * str2 = (struct struct__IO_FILE *)a1;
    g1 = 0x80cc;
    int32_t * v1;
    g2 = (int32_t)&v1;
    function_404ba0(*(int32_t *)g3);
    int32_t str = (int32_t)a2; // 0x402a43
    if (*a2 == 0) {
        // 0x402bc5
        return (int32_t)(char *)1;
    }
    // 0x402a60
    char str5;
    int32_t v2 = &str5; // 0x402abe_0
    // branch -> 0x402a60
    while (true) {
        char * found_char_pos = strchr((char *)str, *(int32_t *)37); // 0x402a6c
        int32_t v3 = (int32_t)found_char_pos; // 0x402a71_0
        if (found_char_pos == NULL) {
            // 0x402cac
            strcat((char *)str2, (char *)str);
            // branch -> 0x402bc5
            // 0x402bc5
            return (int32_t)(char *)1;
        }
        int32_t str3 = v3 + 1; // 0x402a7b
        char * found_char_pos2 = strchr((char *)str3, *(int32_t *)37); // 0x402a8a
        int32_t v4 = (int32_t)found_char_pos2; // 0x402a95
        if (found_char_pos2 != NULL) {
            int32_t str4 = str; // 0x402a9d
            strncat((char *)str2, (char *)str4, v3 - str4);
            str5 = 0;
            int32_t n = 7; // ebx
            strncat(&str5, (char *)str3, v4 - v3 - 1);
            int32_t * lpBuffer = (int32_t *)((int32_t)str2 + strlen((char *)str2)); // bp-32936
            int32_t v5; // 0x402bb5
            if (strncmp(&str5, "EXEDIR", n) % 2 == 0) {
                // 0x402c20
                strncat((char *)str2, (char *)str6, (int32_t)n2);
                // branch -> 0x402ba0
              lab_0x402ba0_3:
                // 0x402ba0
                if (g28 != 0) {
                  lab_0x402bf9_2:;
                    int32_t v6 = *lpBuffer; // 0x402bfc
                    v1 = (int32_t *)v6;
                    fprintf((struct struct__IO_FILE *)g28, "Substitute:\t%s = %s\n", &str5, (char *)v6);
                    // branch -> 0x402ba9
                }
            } else {
                // 0x402b0b
                if (strncmp(&str5, "EXEFILE", 8) % 2 == 0) {
                    // 0x402c41
                    strcat((char *)str2, (char *)str6);
                    // branch -> 0x402bf0
                  lab_0x402bf0_2:
                    // 0x402bf0
                    if (g28 != 0) {
                        goto lab_0x402bf9_2;
                    }
                  lab_0x402ba9:
                    // 0x402ba9
                    g7 = v4;
                    v5 = v4 + 1;
                    if (*(char *)v5 == 0) {
                        // break -> 0x402bc5
                        break;
                    }
                    str = v5;
                    // continue -> 0x402a60
                    continue;
                } else {
                    // 0x402b24
                    if (strncmp(&str5, "PWD", 4) % 2 == 0) {
                        // 0x402c55
                        GetCurrentDirectoryA(*(int32_t *)260, (char *)*lpBuffer);
                        // branch -> 0x402ba0
                        goto lab_0x402ba0_3;
                    } else {
                        // 0x402b3d
                        if (strncmp(&str5, "OLDPWD", n) % 2 == 0) {
                            // 0x402c73
                            strcat((char *)str2, g14);
                            // branch -> 0x402bf0
                            goto lab_0x402bf0_2;
                        } else {
                            // 0x402b53
                            g5 = 0x406273;
                            g3 = v2;
                            if (strstr(&str5, "HKEY") == &str5) {
                                // 0x402c8c
                                function_402060((int32_t *)&str5, (int32_t *)*lpBuffer);
                                // branch -> 0x402ba0
                                goto lab_0x402ba0_3;
                            } else {
                                // 0x402b78
                                int32_t lpBuffer2;
                                if (GetEnvironmentVariableA(&str5, (char *)&lpBuffer2, 0x7fff) == 0) {
                                    goto lab_0x402ba0_3;
                                }
                                // 0x402bcd
                                strcat((char *)str2, (char *)&lpBuffer2);
                                // branch -> 0x402bf0
                                goto lab_0x402bf0_2;
                            }
                        }
                    }
                }
            }
            // 0x402ba9
            g7 = v4;
            v5 = v4 + 1;
            if (*(char *)v5 == 0) {
                // break -> 0x402bc5
                break;
            }
            str = v5;
            // continue -> 0x402a60
            continue;
        }
        // 0x402bc5
        return (int32_t)NULL;
    }
    // 0x402bc5
    return (int32_t)(char *)1;
}

// Address range: 0x402cd0 - 0x402ff5
int32_t function_402cd0(int32_t * a1, char * a2, int32_t lpName, int32_t a4, int32_t a5, char * str3) {
    struct struct__IO_FILE * v1 = (struct struct__IO_FILE *)a1;
    int32_t v2;
    memset((char *)&v2, 0, 5);
    int32_t str = &v2; // edi
    int32_t * hResInfo = FindResourceExA((int32_t *)g31, (char *)10, (char *)((int32_t)a2 % 0x10000), 1024); // 0x402d1b
    if (hResInfo == NULL) {
        // 0x402f58
        abort();
        // UNREACHABLE
    }
    int32_t * hResData2 = LoadResource((int32_t *)g31, hResInfo); // 0x402d38
    int32_t v3; // 0x402df7
    int32_t v4; // 0x402e45
    int32_t v5; // bp+324
    int32_t str_as_i; // 0x402d6f
    int32_t * hResInfo2; // 0x402dab
    int32_t * hResData; // 0x402dc8
    char * v6; // 0x402dd7
    int32_t str_as_i2; // 0x402dff
    int32_t len; // 0x402e9d
    int32_t result; // 0x402e45
    int32_t v7; // 0x402d6f
    int32_t len2; // 0x402ebc
    int32_t v8;
    int32_t stream; // 0x402ed4
    int32_t stream2; // 0x402f39
    int32_t v9; // 0x402e3b
    unsigned char v10; // 0x402df0
    struct struct__IO_FILE * str2; // 0x402e88_0
    int32_t v11; // 0x402e64
    uint64_t v12; // 0x402e17
    if (hResData2 == NULL) {
        // 0x402d6c
        str_as_i = atoi((char *)str);
        memset((char *)&v8, 0, 5);
        str = &v8;
        hResInfo2 = FindResourceExA((int32_t *)g31, (char *)10, (char *)lpName, 1024);
        if (hResInfo2 == NULL) {
            // 0x402f44
            abort();
            // UNREACHABLE
        }
        // 0x402dbb
        hResData = LoadResource((int32_t *)g31, hResInfo2);
        if (hResData == NULL) {
            // 0x402dfc
            str_as_i2 = atoi((char *)str);
            v12 = (int64_t)str_as_i2 * (int64_t)a4;
            g7 = 0;
            g5 = 0x6400000;
            v9 = (str_as_i2 >> 31) * a4;
            g3 = v9;
            v4 = *(int32_t *)(int32_t)v12;
            result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
            v7 = str_as_i < result ? result : str_as_i;
            if (v7 < 1) {
                // 0x402ecc
                return result;
            }
            // 0x402e57
            v11 = v7 - 1024;
            stream = g28;
            if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
                // 0x402ed4
                if (stream != 0) {
                    // 0x402ede
                    fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
                    // branch -> 0x402e88
                }
                // 0x402e88
                str2 = v1;
                str = (int32_t)str2;
                strcat((char *)str2, str3);
                len = strlen((char *)str);
                _itoa(*(int32_t *)v7, (char *)(str + len), 10);
                len2 = strlen((char *)str);
                *(int16_t *)(str + len2) = 0x206d;
                *(char *)(len2 + 2 + str) = 0;
                // branch -> 0x402ecc
                // 0x402ecc
                return len2;
            }
            // 0x402e71
            if (stream == 0) {
                // 0x402e7f
                // branch -> 0x402e88
            } else {
                // 0x402e7f
                fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
                stream2 = g28;
                if (stream2 != 0) {
                    // 0x402ede
                    fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
                    // branch -> 0x402e88
                }
            }
            // 0x402e88
            str2 = v1;
            str = (int32_t)str2;
            strcat((char *)str2, str3);
            len = strlen((char *)str);
            _itoa(*(int32_t *)1024, (char *)(str + len), 10);
            len2 = strlen((char *)str);
            *(int16_t *)(str + len2) = 0x206d;
            *(char *)(len2 + 2 + str) = 0;
            // branch -> 0x402ecc
            // 0x402ecc
            return len2;
        }
        // 0x402dd4
        v6 = LockResource(hResData);
        if (v6 == NULL) {
            // 0x402dfc
            str_as_i2 = atoi((char *)str);
            v12 = (int64_t)str_as_i2 * (int64_t)a4;
            g7 = 0;
            g5 = 0x6400000;
            v9 = (str_as_i2 >> 31) * a4;
            g3 = v9;
            v4 = *(int32_t *)(int32_t)v12;
            result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
            v7 = str_as_i < result ? result : str_as_i;
            if (v7 < 1) {
                // 0x402ecc
                return result;
            }
            // 0x402e57
            v11 = v7 - 1024;
            stream = g28;
            if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
                // 0x402ed4
                if (stream != 0) {
                    // 0x402ede
                    fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
                    // branch -> 0x402e88
                }
                // 0x402e88
                str2 = v1;
                str = (int32_t)str2;
                strcat((char *)str2, str3);
                len = strlen((char *)str);
                _itoa(*(int32_t *)v7, (char *)(str + len), 10);
                len2 = strlen((char *)str);
                *(int16_t *)(str + len2) = 0x206d;
                *(char *)(len2 + 2 + str) = 0;
                // branch -> 0x402ecc
                // 0x402ecc
                return len2;
            }
            // 0x402e71
            if (stream == 0) {
                // 0x402e7f
                // branch -> 0x402e88
            } else {
                // 0x402e7f
                fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
                stream2 = g28;
                if (stream2 != 0) {
                    // 0x402ede
                    fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
                    // branch -> 0x402e88
                }
            }
            // 0x402e88
            str2 = v1;
            str = (int32_t)str2;
            strcat((char *)str2, str3);
            len = strlen((char *)str);
            _itoa(*(int32_t *)1024, (char *)(str + len), 10);
            len2 = strlen((char *)str);
            *(int16_t *)(str + len2) = 0x206d;
            *(char *)(len2 + 2 + str) = 0;
            // branch -> 0x402ecc
            // 0x402ecc
            return len2;
        }
        // 0x402de5
        v5 = 0;
        v10 = v6[v5];
        *(char *)(str + v5) = v10;
        v3 = 1;
        // branch -> 0x402df0
        while ((int32_t)v10 != 0) {
            // 0x402df0
            v5 = v3;
            v10 = v6[v5];
            *(char *)(str + v5) = v10;
            v3++;
            // continue -> 0x402df0
        }
        // 0x402dfc
        str_as_i2 = atoi((char *)str);
        v12 = (int64_t)str_as_i2 * (int64_t)a4;
        g7 = 0;
        g5 = 0x6400000;
        v9 = (str_as_i2 >> 31) * a4;
        g3 = v9;
        v4 = *(int32_t *)(int32_t)v12;
        result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
        v7 = str_as_i < result ? result : str_as_i;
        if (v7 < 1) {
            // 0x402ecc
            return result;
        }
        // 0x402e57
        v11 = v7 - 1024;
        stream = g28;
        if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
            // 0x402ed4
            if (stream != 0) {
                // 0x402ede
                fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
                // branch -> 0x402e88
            }
            // 0x402e88
            str2 = v1;
            str = (int32_t)str2;
            strcat((char *)str2, str3);
            len = strlen((char *)str);
            _itoa(*(int32_t *)v7, (char *)(str + len), 10);
            len2 = strlen((char *)str);
            *(int16_t *)(str + len2) = 0x206d;
            *(char *)(len2 + 2 + str) = 0;
            // branch -> 0x402ecc
            // 0x402ecc
            return len2;
        }
        // 0x402e71
        if (stream == 0) {
            // 0x402e7f
            // branch -> 0x402e88
        } else {
            // 0x402e7f
            fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
            stream2 = g28;
            if (stream2 != 0) {
                // 0x402ede
                fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
                // branch -> 0x402e88
            }
        }
        // 0x402e88
        str2 = v1;
        str = (int32_t)str2;
        strcat((char *)str2, str3);
        len = strlen((char *)str);
        _itoa(*(int32_t *)1024, (char *)(str + len), 10);
        len2 = strlen((char *)str);
        *(int16_t *)(str + len2) = 0x206d;
        *(char *)(len2 + 2 + str) = 0;
        // branch -> 0x402ecc
        // 0x402ecc
        return len2;
    }
    char * v13 = LockResource(hResData2); // 0x402d47
    if (v13 == NULL) {
        // 0x402d6c
        str_as_i = atoi((char *)str);
        memset((char *)&v8, 0, 5);
        str = &v8;
        hResInfo2 = FindResourceExA((int32_t *)g31, (char *)10, (char *)lpName, 1024);
        if (hResInfo2 == NULL) {
            // 0x402f44
            abort();
            // UNREACHABLE
        }
        // 0x402dbb
        hResData = LoadResource((int32_t *)g31, hResInfo2);
        if (hResData != NULL) {
            // 0x402dd4
            v6 = LockResource(hResData);
            if (v6 != NULL) {
                // 0x402de5
                v5 = 0;
                v10 = v6[v5];
                *(char *)(str + v5) = v10;
                v3 = 1;
                // branch -> 0x402df0
                while ((int32_t)v10 != 0) {
                    // 0x402df0
                    v5 = v3;
                    v10 = v6[v5];
                    *(char *)(str + v5) = v10;
                    v3++;
                    // continue -> 0x402df0
                }
                // 0x402dfc
                str_as_i2 = atoi((char *)str);
                v12 = (int64_t)str_as_i2 * (int64_t)a4;
                g7 = 0;
                g5 = 0x6400000;
                v9 = (str_as_i2 >> 31) * a4;
                g3 = v9;
                v4 = *(int32_t *)(int32_t)v12;
                result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
                v7 = str_as_i < result ? result : str_as_i;
                if (v7 < 1) {
                    // 0x402ecc
                    return result;
                }
                // 0x402e57
                v11 = v7 - 1024;
                stream = g28;
                if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
                    // 0x402ed4
                    if (stream != 0) {
                        // 0x402ede
                        fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
                        // branch -> 0x402e88
                    }
                    // 0x402e88
                    str2 = v1;
                    str = (int32_t)str2;
                    strcat((char *)str2, str3);
                    len = strlen((char *)str);
                    _itoa(*(int32_t *)v7, (char *)(str + len), 10);
                    len2 = strlen((char *)str);
                    *(int16_t *)(str + len2) = 0x206d;
                    *(char *)(len2 + 2 + str) = 0;
                    // branch -> 0x402ecc
                    // 0x402ecc
                    return len2;
                }
                // 0x402e71
                if (stream == 0) {
                    // 0x402e7f
                    // branch -> 0x402e88
                } else {
                    // 0x402e7f
                    fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
                    stream2 = g28;
                    if (stream2 != 0) {
                        // 0x402ede
                        fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
                        // branch -> 0x402e88
                    }
                }
                // 0x402e88
                str2 = v1;
                str = (int32_t)str2;
                strcat((char *)str2, str3);
                len = strlen((char *)str);
                _itoa(*(int32_t *)1024, (char *)(str + len), 10);
                len2 = strlen((char *)str);
                *(int16_t *)(str + len2) = 0x206d;
                *(char *)(len2 + 2 + str) = 0;
                // branch -> 0x402ecc
                // 0x402ecc
                return len2;
            }
        }
        // 0x402dfc
        str_as_i2 = atoi((char *)str);
        v12 = (int64_t)str_as_i2 * (int64_t)a4;
        g7 = 0;
        g5 = 0x6400000;
        v9 = (str_as_i2 >> 31) * a4;
        g3 = v9;
        v4 = *(int32_t *)(int32_t)v12;
        result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
        v7 = str_as_i < result ? result : str_as_i;
        if (v7 < 1) {
            // 0x402ecc
            return result;
        }
        // 0x402e57
        v11 = v7 - 1024;
        stream = g28;
        if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
            // 0x402ed4
            if (stream != 0) {
                // 0x402ede
                fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
                // branch -> 0x402e88
            }
            // 0x402e88
            str2 = v1;
            str = (int32_t)str2;
            strcat((char *)str2, str3);
            len = strlen((char *)str);
            _itoa(*(int32_t *)v7, (char *)(str + len), 10);
            len2 = strlen((char *)str);
            *(int16_t *)(str + len2) = 0x206d;
            *(char *)(len2 + 2 + str) = 0;
            // branch -> 0x402ecc
            // 0x402ecc
            return len2;
        }
        // 0x402e71
        if (stream == 0) {
            // 0x402e7f
            // branch -> 0x402e88
        } else {
            // 0x402e7f
            fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
            stream2 = g28;
            if (stream2 != 0) {
                // 0x402ede
                fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
                // branch -> 0x402e88
            }
        }
        // 0x402e88
        str2 = v1;
        str = (int32_t)str2;
        strcat((char *)str2, str3);
        len = strlen((char *)str);
        _itoa(*(int32_t *)1024, (char *)(str + len), 10);
        len2 = strlen((char *)str);
        *(int16_t *)(str + len2) = 0x206d;
        *(char *)(len2 + 2 + str) = 0;
        // branch -> 0x402ecc
        // 0x402ecc
        return len2;
    }
    int32_t v14 = 0; // bp+320
    unsigned char v15 = v13[v14]; // 0x402d60
    *(char *)(str + v14) = v15;
    int32_t v16 = 1; // 0x402d67
    // branch -> 0x402d60
    while ((int32_t)v15 != 0) {
        // 0x402d60
        v14 = v16;
        v15 = v13[v14];
        *(char *)(str + v14) = v15;
        v16++;
        // continue -> 0x402d60
    }
    // 0x402d6c
    str_as_i = atoi((char *)str);
    memset((char *)&v8, 0, 5);
    str = &v8;
    hResInfo2 = FindResourceExA((int32_t *)g31, (char *)10, (char *)lpName, 1024);
    if (hResInfo2 == NULL) {
        // 0x402f44
        abort();
        // UNREACHABLE
    }
    // 0x402dbb
    hResData = LoadResource((int32_t *)g31, hResInfo2);
    if (hResData != NULL) {
        // 0x402dd4
        v6 = LockResource(hResData);
        if (v6 != NULL) {
            // 0x402de5
            v5 = 0;
            v10 = v6[v5];
            *(char *)(str + v5) = v10;
            v3 = 1;
            // branch -> 0x402df0
            while ((int32_t)v10 != 0) {
                // 0x402df0
                v5 = v3;
                v10 = v6[v5];
                *(char *)(str + v5) = v10;
                v3++;
                // continue -> 0x402df0
            }
            // 0x402dfc
            str_as_i2 = atoi((char *)str);
            v12 = (int64_t)str_as_i2 * (int64_t)a4;
            g7 = 0;
            g5 = 0x6400000;
            v9 = (str_as_i2 >> 31) * a4;
            g3 = v9;
            v4 = *(int32_t *)(int32_t)v12;
            result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
            v7 = str_as_i < result ? result : str_as_i;
            if (v7 < 1) {
                // 0x402ecc
                return result;
            }
            // 0x402e57
            v11 = v7 - 1024;
            stream = g28;
            if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
                // 0x402ed4
                if (stream != 0) {
                    // 0x402ede
                    fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
                    // branch -> 0x402e88
                }
                // 0x402e88
                str2 = v1;
                str = (int32_t)str2;
                strcat((char *)str2, str3);
                len = strlen((char *)str);
                _itoa(*(int32_t *)v7, (char *)(str + len), 10);
                len2 = strlen((char *)str);
                *(int16_t *)(str + len2) = 0x206d;
                *(char *)(len2 + 2 + str) = 0;
                // branch -> 0x402ecc
                // 0x402ecc
                return len2;
            }
            // 0x402e71
            if (stream == 0) {
                // 0x402e7f
                // branch -> 0x402e88
            } else {
                // 0x402e7f
                fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
                stream2 = g28;
                if (stream2 != 0) {
                    // 0x402ede
                    fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
                    // branch -> 0x402e88
                }
            }
            // 0x402e88
            str2 = v1;
            str = (int32_t)str2;
            strcat((char *)str2, str3);
            len = strlen((char *)str);
            _itoa(*(int32_t *)1024, (char *)(str + len), 10);
            len2 = strlen((char *)str);
            *(int16_t *)(str + len2) = 0x206d;
            *(char *)(len2 + 2 + str) = 0;
            // branch -> 0x402ecc
            // 0x402ecc
            return len2;
        }
    }
    // 0x402dfc
    str_as_i2 = atoi((char *)str);
    v12 = (int64_t)str_as_i2 * (int64_t)a4;
    g7 = 0;
    g5 = 0x6400000;
    v9 = (str_as_i2 >> 31) * a4;
    g3 = v9;
    v4 = *(int32_t *)(int32_t)v12;
    result = function_404bd0(v4, (int32_t)(v12 / 0x100000000) + str_as_i2 * a5 + v9, 0x6400000, 0);
    v7 = str_as_i < result ? result : str_as_i;
    if (v7 < 1) {
        // 0x402ecc
        return result;
    }
    // 0x402e57
    v11 = v7 - 1024;
    stream = g28;
    if (g22 / 256 == (int32_t)(v11 == 0 || v11 < 0 ^ (1023 - v7 & v7) < 0)) {
        // 0x402ed4
        if (stream != 0) {
            // 0x402ede
            fprintf((struct struct__IO_FILE *)stream, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, v7);
            // branch -> 0x402e88
        }
        // 0x402e88
        str2 = v1;
        str = (int32_t)str2;
        strcat((char *)str2, str3);
        len = strlen((char *)str);
        _itoa(*(int32_t *)v7, (char *)(str + len), 10);
        len2 = strlen((char *)str);
        *(int16_t *)(str + len2) = 0x206d;
        *(char *)(len2 + 2 + str) = 0;
        // branch -> 0x402ecc
        // 0x402ecc
        return len2;
    }
    // 0x402e71
    if (stream == 0) {
        // 0x402e7f
        // branch -> 0x402e88
    } else {
        // 0x402e7f
        fprintf((struct struct__IO_FILE *)stream, "Heap limit:\tReduced %d MB heap size to 32-bit maximum %d MB\n", v7, 1024);
        stream2 = g28;
        if (stream2 != 0) {
            // 0x402ede
            fprintf((struct struct__IO_FILE *)stream2, "Heap %s:\tRequested %d MB / %d%%, Available: %d MB, Heap size: %d MB\n", str3, str_as_i, str_as_i2, a4 / 0x100000 | 0x1000 * a5, 1024);
            // branch -> 0x402e88
        }
    }
    // 0x402e88
    str2 = v1;
    str = (int32_t)str2;
    strcat((char *)str2, str3);
    len = strlen((char *)str);
    _itoa(*(int32_t *)1024, (char *)(str + len), 10);
    len2 = strlen((char *)str);
    *(int16_t *)(str + len2) = 0x206d;
    *(char *)(len2 + 2 + str) = 0;
    // branch -> 0x402ecc
    // 0x402ecc
    return len2;
}

// Address range: 0x402ff6 - 0x4030b9
int32_t function_402ff6(char * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g2; // 0x403000
    char * v2 = (char *)v1; // bp-4
    g1 = 0x8028;
    g2 = (int32_t)&v2;
    function_404ba0(v1);
    int32_t v3;
    int32_t lpBuffer = &v3; // esi
    int32_t str2 = (int32_t)a1; // edi
    memset((char *)&v3, 0, 0x7fff);
    v2 = "Path";
    int32_t v4 = 0x7ffe - GetEnvironmentVariableA("Path", (char *)lpBuffer, 0x7fff); // ebx
    char * str = (char *)str2; // 0x403059_0
    v2 = str;
    if (v4 < strlen(str)) {
        // 0x403067
        return 0;
    }
    // 0x403076
    *(int16_t *)(lpBuffer + strlen((char *)lpBuffer)) = 59;
    strcat((char *)lpBuffer, (char *)str2);
    v2 = "Path";
    return SetEnvironmentVariableA("Path", (char *)lpBuffer);
}

// Address range: 0x4030ba - 0x4030bf
int32_t function_4030ba(int32_t a1) {
    // 0x4030ba
    return g5;
}

// Address range: 0x4030c0 - 0x40475f
int32_t function_4030c0(struct struct__IO_FILE * a1, struct struct__IO_FILE * a2, char * a3, char * a4) {
    g1 = 0x287f8;
    int32_t * v1;
    int32_t v2 = (int32_t)&v1; // 0x4030c6_0
    g2 = v2;
    function_404ba0(*v1);
    int32_t * v3;
    memset((char *)&v3, 0, 0x8000);
    v1 = NULL;
    int32_t * moduleHandle = GetModuleHandleA(NULL); // 0x4030fa
    g31 = (int32_t)moduleHandle;
    if (moduleHandle == NULL) {
        // 0x40310d
        return 0;
    }
    // 0x403120
    int32_t * str3;
    int32_t v4 = (int32_t)&str3; // 0x403127_0
    int32_t lpFilename = v4; // edi
    memset((char *)&str3, 0, 260);
    int32_t nSize = 260; // 0x403148
    int32_t v5 = g31; // 0x403150
    g3 = v5;
    int32_t * hModule = (int32_t *)v5; // 0x403156_0
    v1 = hModule;
    if (GetModuleFileNameA(hModule, (char *)lpFilename, nSize) == 0) {
        // 0x403420
        return 0;
    }
    // 0x403169
    v1 = (int32_t *)lpFilename;
    g7 = 92;
    char c = *(char *)92;
    int32_t n = (int32_t)strrchr((char *)lpFilename, (int32_t)c) - lpFilename; // 0x40317a
    int32_t v6 = n + 1; // 0x403182
    g1 = v6;
    if (v6 == 0) {
        // 0x403420
        return 0;
    }
    struct struct__IO_FILE * str = (struct struct__IO_FILE *)nSize; // 0x403192_0
    g5 = (int32_t)str;
    v1 = &str->e0;
    if (strstr((char *)str, "--l4j-debug") != NULL) {
        // 0x4031a5
        int32_t v7;
        int32_t str2 = &v7; // ebx
        g7 = 0x3468636e;
        memset((char *)&v7, 0, 260);
        g1 = v4;
        strncpy((char *)str2, (char *)&str3, n);
        strlen((char *)str2);
        v1 = (int32_t *)str2;
        struct struct__IO_FILE * file = fopen((char *)str2, "a"); // 0x403212
        g28 = (int32_t)file;
        if (file == NULL) {
            // 0x40310d
            return 0;
        }
        int32_t v8 = g5; // 0x403226
        g3 = v4;
        g5 = 0x406330;
        v1 = &file->e0;
        fprintf(file, "\n\nCmdLine:\t%s %s\n", &str3, (char *)v8);
        // branch -> 0x403245
    }
    // 0x403245
    v1 = (int32_t *)"kernel32";
    int32_t * moduleHandle2 = GetModuleHandleA("kernel32"); // 0x40324c
    g6 = 0x40606b;
    v1 = moduleHandle2;
    int32_t (*func)() = GetProcAddress(moduleHandle2, "IsWow64Process"); // 0x403260
    g8 = v2;
    if (func != NULL) {
        int32_t * processHandle = GetCurrentProcess(); // 0x40326e
        v1 = processHandle;
        g4 = 0x40fba4;
        ((int32_t (*)(int32_t, int32_t))func)(*processHandle, g24);
        // branch -> 0x403284
    }
    // 0x403284
    if (g28 != 0) {
        struct struct__IO_FILE * v9 = g24 == 0 ? (struct struct__IO_FILE *)0x40607e : (struct struct__IO_FILE *)0x40607a; // 0x4032a1
        v1 = (int32_t *)g28;
        fprintf((struct struct__IO_FILE *)g28, "WOW64:\t\t%s\n", v9);
        // branch -> 0x4032b6
    }
    // 0x4032b6
    v1 = (int32_t *)22;
    g3 = 0x405010;
    function_401e10((char *)22, g20);
    v1 = (int32_t *)10;
    function_401e10((char *)10, "Launch4j");
    v1 = (int32_t *)101;
    if (function_401e10((char *)101, g19) == 0) {
        // 0x40310d
        return 0;
    }
    // 0x4032ff
    v1 = (int32_t *)23;
    function_401e10((char *)23, g21);
    if ((int32_t)g21 % 256 == 0) {
        // 0x40336b
        abort();
        // UNREACHABLE
    }
    int32_t v10 = 12;
    v1 = &v10;
    abort();
    // UNREACHABLE
}

// Address range: 0x404760 - 0x40479f
int32_t function_404760(void) {
    // 0x404760
    CloseHandle(*(int32_t *)g33);
    int32_t hObject = g32; // 0x404774
    g1 = hObject;
    CloseHandle(*(int32_t *)hObject);
    if (g28 % 2 == 0) {
        // 0x404790
        return g28;
    }
    // 0x404792
    return fclose((struct struct__IO_FILE *)g28) % 2 != 0;
}

// Address range: 0x4047a0 - 0x40493f
int32_t function_4047a0(struct struct__IO_FILE * a1, char * a2, char * a3, struct STARTUPINFO * a4, struct PROCESS_INFORMATION * a5) {
    int32_t lpCurrentDirectory = (int32_t)a3; // bp+12
    g1 = 0x809c;
    struct SECURITY_ATTRIBUTES * v1;
    g2 = (int32_t)&v1;
    function_404ba0(*(int32_t *)g3);
    int32_t v2;
    int32_t lpStartupInfo = &v2; // esi
    memset((char *)&g32, 0, 4);
    memset((char *)lpStartupInfo, 0, 68);
    int16_t str; // bp-32876
    int32_t str2 = &str; // ebx
    str = 34;
    struct SECURITY_ATTRIBUTES * lpExitCode = (struct SECURITY_ATTRIBUTES *)-1;
    v2 = 68;
    strcat((char *)&str, g13);
    int32_t len = strlen((char *)str2); // 0x404813
    *(int16_t *)(str2 + len) = 0x2022;
    *(char *)(len + 2 + str2) = 0;
    strcat((char *)str2, g12);
    lpCurrentDirectory = 0;
    bool lpEnvironment = false;
    lpEnvironment = true;
    v1 = NULL;
    bool v3 = CreateProcessA(NULL, (char *)str2, NULL, NULL, true, g30, (int32_t *)&lpEnvironment, (char *)&lpCurrentDirectory, (struct STARTUPINFO *)lpStartupInfo, (struct PROCESS_INFORMATION *)&g32); // 0x404875
    if (!v3) {
        // 0x404890
        return (int32_t)lpExitCode;
    }
    // 0x404881
    if ((struct struct__IO_FILE *)g30 == NULL) {
        // 0x404888
        lpExitCode = NULL;
        // branch -> 0x404890
        // 0x404890
        return (int32_t)lpExitCode;
    }
    // 0x4048a0
    WaitForSingleObject((int32_t *)g32, -1);
    GetExitCodeProcess((int32_t *)g32, (int32_t *)&lpExitCode);
    if (g28 != 0) {
        // 0x404917
        fprintf((struct struct__IO_FILE *)g28, "Exit code:\t%d\n", (int32_t)lpExitCode);
        // branch -> 0x4048df
    }
    // 0x4048df
    CloseHandle(*(int32_t *)g33);
    CloseHandle(*(int32_t *)g32);
    if (g28 != 0) {
        // 0x40490a
        fclose((struct struct__IO_FILE *)g28);
        // branch -> 0x404890
    }
    // 0x404890
    return (int32_t)lpExitCode;
}

// Address range: 0x404940 - 0x404a5f
int32_t function_404940(int32_t a1) {
    g1 = 16;
    int32_t v1;
    g2 = &v1;
    struct STARTUPINFO * v2;
    function_404ba0((int32_t)v2);
    function_404b30();
    char * commandLine = GetCommandLineA(); // 0x404959
    int32_t lpStartupInfo;
    GetStartupInfoA((struct STARTUPINFO *)&lpStartupInfo);
    int32_t v3; // 0x404a30
    int32_t * moduleHandle; // 0x404a1d
    uint16_t v4;
    char v5;
    if (commandLine == NULL) {
        // 0x404a16
        moduleHandle = GetModuleHandleA(NULL);
        v3 = v5 == 1 ? 10 : (int32_t)v4;
        g6 = v3;
        g3 = 0;
        function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)NULL, (char *)v3);
        return 1;
    }
    unsigned char v6 = *commandLine; // 0x40497842
    int32_t v7 = v6; // 0x40497843
    int32_t v8 = v6 == 32; // 0x40497e45
    int32_t v9 = v6 == 9; // 0x40498449
    int32_t v10 = v9 | g6 & -256; // 0x40498451
    int32_t v11 = v8 | (int32_t)&lpStartupInfo & -256 | v10; // 0x40498752
    char * v12;
    uint32_t v13; // 0x4049b0_0
    char * v14; // 0x4049d1_0
    char * v15; // 0x404a01_0
    char * v16; // 0x404a53_07
    char * v17; // 0x404a53_08
    int32_t v18; // 0x4049bb
    unsigned char v19; // 0x4049d1
    unsigned char v20; // 0x404a01
    int32_t v21; // 0x4049d1
    int32_t v22; // 0x404a10
    int32_t v23; // 0x404a1013
    int32_t v24; // 0x404995
    int32_t v25; // 0x4049d7
    int32_t v26; // 0x4049f9
    int32_t v27; // 0x404a07
    int32_t v28; // 0x4049f0
    if (v11 == 1) {
        // 0x40498d
        v12 = (char *)v7;
        if (v12 == (char *)34) {
            v19 = *(char *)((int32_t)(char *)34 + 1);
            v21 = v19;
            v14 = (char *)v21;
            v25 = v19 != 34;
            while (v19 != 0) {
                // 0x4049d0
                v19 = *(char *)((int32_t)v14 + 1);
                v21 = v19;
                v14 = (char *)v21;
                v25 = ((int32_t)(v19 == 34) | v25 & -256) ^ 1;
                // continue -> 0x4049d0
            }
            // 0x4049e5
            if (v14 == (char *)34) {
                // 0x404a52
                v17 = (char *)(int32_t)*(char *)(v21 + 1);
                // branch -> 0x4049f0
            } else {
                v17 = v14;
            }
            // 0x4049f0
            v28 = 0x1000000 * (int32_t)v17;
            v26 = (int32_t)(v28 == 0x9000000) | v19 != 0 & -256;
            v23 = (int32_t)(v28 == 0x20000000) | v25 & -256 | v26;
            if (v23 == 1) {
                // 0x404a16
                moduleHandle = GetModuleHandleA(NULL);
                v3 = v5 == 1 ? 10 : (int32_t)v4;
                g6 = v3;
                g3 = 0;
                function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v17, (char *)v3);
                return 1;
            }
            v20 = *(char *)((int32_t)v17 + 1);
            v15 = (char *)(int32_t)v20;
            v27 = (int32_t)(v20 == 32) | v26 & -256;
            v22 = (int32_t)(v20 == 9) | v23 & -256 | v27;
            while (v22 != 1) {
                // 0x404a00
                v20 = *(char *)((int32_t)v15 + 1);
                v15 = (char *)(int32_t)v20;
                v27 = (int32_t)(v20 == 32) | v27 & -256;
                v22 = (int32_t)(v20 == 9) | v22 & -256 | v27;
                // continue -> 0x404a00
            }
            // 0x404a16
            moduleHandle = GetModuleHandleA(NULL);
            v3 = v5 == 1 ? 10 : (int32_t)v4;
            g6 = v3;
            g3 = 0;
            function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v15, (char *)v3);
            return 1;
        }
        // 0x404992
        v24 = v8 ^ 1;
        if (v6 == 9 != (v6 == 32)) {
            v18 = v24;
            v16 = v12;
            while (true) {
                // 0x4049b0
                v13 = (int32_t)v16;
                if (v13 % 256 != 0) {
                    goto lab_0x4049b4;
                }
                v17 = v16;
                // 0x4049f0
                v28 = 0x1000000 * (int32_t)v17;
                v26 = (int32_t)(v28 == 0x9000000) | (v9 ^ 1) & -256;
                v23 = (int32_t)(v28 == 0x20000000) | v18 & -256 | v26;
                if (v23 == 1) {
                    // 0x404a16
                    moduleHandle = GetModuleHandleA(NULL);
                    v3 = v5 == 1 ? 10 : (int32_t)v4;
                    g6 = v3;
                    g3 = 0;
                    function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v17, (char *)v3);
                    return 1;
                }
                v20 = *(char *)((int32_t)v17 + 1);
                v15 = (char *)(int32_t)v20;
                v27 = (int32_t)(v20 == 32) | v26 & -256;
                v22 = (int32_t)(v20 == 9) | v23 & -256 | v27;
                while (v22 != 1) {
                    // 0x404a00
                    v20 = *(char *)((int32_t)v15 + 1);
                    v15 = (char *)(int32_t)v20;
                    v27 = (int32_t)(v20 == 32) | v27 & -256;
                    v22 = (int32_t)(v20 == 9) | v22 & -256 | v27;
                    // continue -> 0x404a00
                }
                // 0x404a16
                moduleHandle = GetModuleHandleA(NULL);
                v3 = v5 == 1 ? 10 : (int32_t)v4;
                g6 = v3;
                g3 = 0;
                function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v15, (char *)v3);
                return 1;
            }
        } else {
            v17 = v12;
        }
        // 0x4049f0
        v28 = 0x1000000 * (int32_t)v17;
        v26 = (int32_t)(v28 == 0x9000000) | v24 & -256;
        v23 = (int32_t)(v28 == 0x20000000) | v24 & -256 | v26;
        if (v23 == 1) {
            // 0x404a16
            moduleHandle = GetModuleHandleA(NULL);
            v3 = v5 == 1 ? 10 : (int32_t)v4;
            g6 = v3;
            g3 = 0;
            function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v17, (char *)v3);
            return 1;
        }
        v20 = *(char *)((int32_t)v17 + 1);
        v15 = (char *)(int32_t)v20;
        v27 = (int32_t)(v20 == 32) | v26 & -256;
        v22 = (int32_t)(v20 == 9) | v23 & -256 | v27;
        while (v22 != 1) {
            // 0x404a00
            v20 = *(char *)((int32_t)v15 + 1);
            v15 = (char *)(int32_t)v20;
            v27 = (int32_t)(v20 == 32) | v27 & -256;
            v22 = (int32_t)(v20 == 9) | v22 & -256 | v27;
            // continue -> 0x404a00
        }
        // 0x404a16
        moduleHandle = GetModuleHandleA(NULL);
        v3 = v5 == 1 ? 10 : (int32_t)v4;
        g6 = v3;
        g3 = 0;
        function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v15, (char *)v3);
        return 1;
    }
    unsigned char v29 = *(char *)(v7 + 1); // 0x404978
    int32_t v30 = v29; // 0x404978
    int32_t v31 = v29 == 32; // 0x40497e
    int32_t v32 = v29 == 9; // 0x404984
    int32_t v33 = v32 | v10 & -256; // 0x404984
    while ((v31 || v11 & -256 || v33) != 1) {
        // 0x404977
        v11 = v31 | v11 & -256 | v33;
        v29 = *(char *)(v30 + 1);
        v30 = v29;
        v31 = v29 == 32;
        v32 = v29 == 9;
        v33 = v32 | v33 & -256;
        // continue -> 0x404977
    }
    // 0x40498d
    v12 = (char *)v30;
    int32_t v34; // 0x4049f3
    int32_t v35; // 0x4049f9
    if (v12 == (char *)34) {
        v19 = *(char *)((int32_t)(char *)34 + 1);
        v21 = v19;
        v14 = (char *)v21;
        v25 = v19 != 34;
        int32_t v36 = v19 != 0; // 0x4049de
        while (v19 != 0) {
            // 0x4049d0
            v19 = *(char *)((int32_t)v14 + 1);
            v21 = v19;
            v14 = (char *)v21;
            v25 = ((int32_t)(v19 == 34) | v25 & -256) ^ 1;
            v36 = v19 != 0;
            // continue -> 0x4049d0
        }
        // 0x4049e5
        if (v14 == (char *)34) {
            // 0x404a52
            v35 = v36;
            v34 = v25;
            v17 = (char *)(int32_t)*(char *)(v21 + 1);
            // branch -> 0x4049f0
        } else {
            v35 = v36;
            v34 = v25;
            v17 = v14;
        }
    } else {
        // 0x404992
        v24 = v31 ^ 1;
        if (v29 == 9 != (v29 == 32)) {
            int32_t v37 = v32 ^ 1; // 0x4049f926
            v18 = v24;
            v16 = v12;
            while (true) {
                // 0x4049b0
                v13 = (int32_t)v16;
                if (v13 % 256 != 0) {
                  lab_0x4049b4:;
                    unsigned char v38 = *(char *)(v13 + 1); // 0x4049b5
                    char * v39 = (char *)(int32_t)v38; // 0x4049b5_0
                    int32_t v40 = ((int32_t)(v38 == 32) | v18 & -256) ^ 1; // 0x4049bb
                    int32_t v41 = v38 != 9; // 0x4049c3
                    if (v38 == 9) {
                        v35 = v41;
                        v34 = v40;
                        v17 = v39;
                        // break -> 0x4049f0
                        break;
                    }
                    v37 = v41;
                    v18 = v40;
                    v16 = v39;
                    // continue -> 0x4049b0
                    continue;
                } else {
                    v35 = v37;
                    v34 = v18;
                    v17 = v16;
                }
            }
            // 0x4049f0
            v28 = 0x1000000 * (int32_t)v17;
            v26 = (int32_t)(v28 == 0x9000000) | v35 & -256;
            v23 = (int32_t)(v28 == 0x20000000) | v34 & -256 | v26;
            if (v23 == 1) {
                // 0x404a16
                moduleHandle = GetModuleHandleA(NULL);
                v3 = v5 == 1 ? 10 : (int32_t)v4;
                g6 = v3;
                g3 = 0;
                function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v17, (char *)v3);
                return 1;
            }
            v20 = *(char *)((int32_t)v17 + 1);
            v15 = (char *)(int32_t)v20;
            v27 = (int32_t)(v20 == 32) | v26 & -256;
            v22 = (int32_t)(v20 == 9) | v23 & -256 | v27;
            while (v22 != 1) {
                // 0x404a00
                v20 = *(char *)((int32_t)v15 + 1);
                v15 = (char *)(int32_t)v20;
                v27 = (int32_t)(v20 == 32) | v27 & -256;
                v22 = (int32_t)(v20 == 9) | v22 & -256 | v27;
                // continue -> 0x404a00
            }
            // 0x404a16
            moduleHandle = GetModuleHandleA(NULL);
            v3 = v5 == 1 ? 10 : (int32_t)v4;
            g6 = v3;
            g3 = 0;
            function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v15, (char *)v3);
            return 1;
        }
        v35 = v24;
        v34 = v24;
        v17 = v12;
    }
    // 0x4049f0
    v28 = 0x1000000 * (int32_t)v17;
    v26 = (int32_t)(v28 == 0x9000000) | v35 & -256;
    v23 = (int32_t)(v28 == 0x20000000) | v34 & -256 | v26;
    if (v23 == 1) {
        // 0x404a16
        moduleHandle = GetModuleHandleA(NULL);
        v3 = v5 == 1 ? 10 : (int32_t)v4;
        g6 = v3;
        g3 = 0;
        function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v17, (char *)v3);
        return 1;
    }
    v20 = *(char *)((int32_t)v17 + 1);
    v15 = (char *)(int32_t)v20;
    v27 = (int32_t)(v20 == 32) | v26 & -256;
    v22 = (int32_t)(v20 == 9) | v23 & -256 | v27;
    while (v22 != 1) {
        // 0x404a00
        v20 = *(char *)((int32_t)v15 + 1);
        v15 = (char *)(int32_t)v20;
        v27 = (int32_t)(v20 == 32) | v27 & -256;
        v22 = (int32_t)(v20 == 9) | v22 & -256 | v27;
        // continue -> 0x404a00
    }
    // 0x404a16
    moduleHandle = GetModuleHandleA(NULL);
    v3 = v5 == 1 ? 10 : (int32_t)v4;
    g6 = v3;
    g3 = 0;
    function_4013b0((struct struct__IO_FILE *)moduleHandle, NULL, (int32_t *)v15, (char *)v3);
    return 1;
}

// Address range: 0x404a60 - 0x404a8f
int32_t function_404a60(void) {
    // 0x404a86
    return 0;
}

// Address range: 0x404a90 - 0x404a9f
int32_t function_404a90(void) {
    // 0x404a90
    return g1;
}

// Address range: 0x404aa0 - 0x404acf
int32_t function_404aa0(void) {
    // 0x404aa0
    return g11;
}

// Address range: 0x404ad0 - 0x404b2f
int32_t function_404ad0(int32_t a1) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    if (g9.e0 == 0) {
        // 0x404b21
        // branch -> 0x404afa
        // 0x404afa
        return atexit((void (*)())function_404aa0);
    }
    int32_t v2 = 1; // 0x404b15
    while (g9.e1[v2] != 0) {
        // 0x404b15
        v2++;
        // continue -> 0x404b15
    }
    // 0x404b21
    g1 = v2;
    g3 = v2;
    if (v2 == 0) {
        // 0x404afa
        return atexit((void (*)())function_404aa0);
    }
    ((int32_t (*)())*(int32_t *)(4 * v2 + 0x404f98))();
    int32_t v3 = g3 - 1; // 0x404af7
    g3 = v3;
    while (v3 != 0) {
        // 0x404af0
        ((int32_t (*)())*(int32_t *)(4 * v3 + 0x404f98))();
        v3 = g3 - 1;
        g3 = v3;
        // continue -> 0x404af0
    }
    // 0x404afa
    return atexit((void (*)())function_404aa0);
}

// Address range: 0x404b30 - 0x404b9f
int32_t function_404b30(void) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x404b33
    if (g27 == 0) {
        // 0x404b41
        g4 = 1;
        g27 = 1;
        g1 = 0;
        if (g9.e0 == 0) {
            // 0x404b91
            // branch -> 0x404b6a
        } else {
            int32_t v3 = 1; // 0x404b85
            while (g9.e1[v3] != 0) {
                // 0x404b85
                v3++;
                // continue -> 0x404b85
            }
            // 0x404b91
            g1 = v3;
            g6 = 0;
            g3 = v3;
            if (v3 != 0) {
                ((int32_t (*)())*(int32_t *)(4 * v3 + 0x404f98))();
                int32_t v4 = g3 - 1; // 0x404b67
                g3 = v4;
                while (v4 != 0) {
                    // 0x404b60
                    ((int32_t (*)())*(int32_t *)(4 * v4 + 0x404f98))();
                    v4 = g3 - 1;
                    g3 = v4;
                    // continue -> 0x404b60
                }
                // 0x404b6a
                atexit((void (*)())function_404aa0);
                // branch -> 0x404b76
                // 0x404b76
                g3 = v2;
                return function_404aa0;
            }
        }
        // 0x404b6a
        atexit((void (*)())function_404aa0);
        // branch -> 0x404b76
    }
    // 0x404b76
    g3 = v2;
    return function_404aa0;
}

// Address range: 0x404ba0 - 0x404bcf
int32_t function_404ba0(int32_t a1) {
    int32_t v1 = &a1; // 0x404ba3_4
    int32_t v2 = g1;
    int32_t v3;
    int32_t v4; // 0x404bbd
    if (v2 >= 0x1000) {
        uint32_t v5 = v2 - 0x1000;
        int32_t v6 = v5 % 0x1000;
        v4 = v6;
        v3 = v1 - 0x1000 + v6 - v5;
        // branch -> 0x404bbd
    } else {
        v4 = v2;
        v3 = v1;
    }
    // 0x404bbd
    g8 = v3 - v4;
    int32_t v7;
    g4 = v7;
    int32_t v8;
    g1 = v8;
    ((int32_t (*)())v8)();
    return g1;
}

// Address range: 0x404bd0 - 0x404fff
int32_t function_404bd0(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4) {
    // 0x404bd0
    if (a4 == 0) {
        // 0x404bf4
        if (a3 > a2) {
            int32_t result = (0x100000000 * (int64_t)a2 | (int64_t)a1) / (int64_t)a3; // 0x404bfc
            // branch -> 0x404c07
            // 0x404c07
            return result;
        }
        // 0x404c52
        if (a3 == 0) {
            // 0x404c56
            // branch -> 0x404c63
        }
        // 0x404c63
        return (0x100000000 * (int64_t)(a2 % a3) | (int64_t)a1) / (int64_t)a3;
    }
    // 0x404c20
    if (a4 > a2) {
        // 0x404c07
        return 0;
    }
    int32_t v1 = llvm_ctlz_i32(a4, false); // 0x404c2d
    int32_t v2 = 31 - v1; // 0x404c2d
    uint32_t v3 = v2 ^ 31; // 0x404c30
    int32_t result2; // 0x404c0a
    if (v1 == 0) {
        // 0x404c38
        if (((v2 & -256 || (int32_t)(a4 == a2)) ^ 1 || (a4 & -256 || (int32_t)(a1 < a3)) ^ 1) == 1) {
            // 0x404c4e
            result2 = 0;
            // branch -> 0x404c07
        } else {
            result2 = 1;
        }
    } else {
        uint32_t v4 = v3 % 32; // 0x404c98
        int32_t v5 = a4; // 0x404ca4
        if (v4 != 0) {
            // if_404c98_0_true
            v5 = a4 << v4;
            // branch -> after_if_404c98_0
        }
        uint32_t v6 = (32 - v3) % 32; // 0x404ca2
        int32_t v7 = a3; // 0x404ca4
        if (v6 != 0) {
            // if_404ca2_0_true
            v7 = a3 >> v6;
            // branch -> after_if_404ca2_0
        }
        int32_t v8 = a3; // 0x404cd2
        if (v4 != 0) {
            // if_404cad_0_true
            v8 = a3 << v4;
            // branch -> after_if_404cad_0
        }
        int32_t v9 = a2; // 0x404cc9
        if (v6 != 0) {
            // if_404cb3_0_true
            v9 = a2 >> v6;
            // branch -> after_if_404cb3_0
        }
        int32_t v10 = a2; // 0x404cc1
        if (v4 != 0) {
            // if_404cb9_0_true
            v10 = a2 << v4;
            // branch -> after_if_404cb9_0
        }
        int32_t v11 = a1; // 0x404cc1
        if (v6 != 0) {
            // if_404cbf_0_true
            v11 = a1 >> v6;
            // branch -> after_if_404cbf_0
        }
        uint64_t v12 = (int64_t)(v7 | v5); // 0x404cc9
        uint64_t v13 = (int64_t)(v11 | v10) | 0x100000000 * (int64_t)v9; // 0x404cc9
        uint64_t v14 = v13 / v12; // 0x404cc9
        uint32_t v15 = (int32_t)(v13 % v12); // 0x404cc9
        uint64_t v16 = (v14 & 0xffffffff) * (int64_t)v8; // 0x404cd2
        uint32_t v17 = (int32_t)(v16 / 0x100000000); // 0x404cd2
        uint32_t v18 = (int32_t)v16; // 0x404cd2
        if (v17 > v15 || (int32_t)(v18 > a1 << v4) != ((int32_t)(v17 == v15) || v18 & -256)) {
            // 0x404ced
            return unknown_410290();
        }
        result2 = v14;
    }
    // 0x404c07
    return result2;
}

// --------------- Dynamically Linked Functions ---------------

// void __getmainargs(void);
// void __p__environ(void);
// int* __p__fmode();
// void __set_app_type(int at);
// char* _itoa(int value, char *str, int radix);
// _onexit_t _onexit(_onexit_t function);
// int _setmode(int fd, int mode);
// int atexit(void(*)(void));
// int atoi(const char *);
// BOOL WINAPI CloseHandle(_In_ HANDLE hObject);
// BOOL WINAPI CreateProcessA(_In_opt_ LPCTSTR lpApplicationName, _Inout_opt_ LPTSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCTSTR lpCurrentDirectory, _In_ LPSTARTUPINFO lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation);
// int fclose(FILE *);
// HRSRC WINAPI FindResourceExA(_In_opt_ HMODULE hModule, _In_ LPCTSTR lpType, _In_ LPCTSTR lpName, _In_ WORD wLanguage);
// HWND WINAPI FindWindowExA(_In_opt_ HWND hwndParent, _In_opt_ HWND hwndChildAfter, _In_opt_ LPCTSTR lpszClass, _In_opt_ LPCTSTR lpszWindow);
// FILE * fopen(const char *restrict, const char *restrict);
// DWORD WINAPI FormatMessageA(_In_ DWORD dwFlags, _In_opt_ LPCVOID lpSource, _In_ DWORD dwMessageId, _In_ DWORD dwLanguageId, _Out_ LPTSTR lpBuffer, _In_ DWORD nSize, _In_opt_ va_list *Arguments);
// int fprintf(FILE *restrict, const char *restrict, ...);
// size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);
// LPTSTR WINAPI GetCommandLineA(void);
// DWORD WINAPI GetCurrentDirectoryA(_In_ DWORD nBufferLength, _Out_ LPTSTR lpBuffer);
// HANDLE WINAPI GetCurrentProcess(void);
// DWORD WINAPI GetEnvironmentVariableA(_In_opt_ LPCTSTR lpName, _Out_opt_ LPTSTR lpBuffer, _In_ DWORD nSize);
// BOOL WINAPI GetExitCodeProcess(_In_ HANDLE hProcess, _Out_ LPDWORD lpExitCode);
// DWORD WINAPI GetLastError(void);
// DWORD WINAPI GetModuleFileNameA(_In_opt_ HMODULE hModule, _Out_ LPTSTR lpFilename, _In_ DWORD nSize);
// HMODULE WINAPI GetModuleHandleA(_In_opt_ LPCTSTR lpModuleName);
// FARPROC WINAPI GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID WINAPI GetStartupInfoA(_Out_ LPSTARTUPINFO lpStartupInfo);
// int WINAPI GetWindowTextA(_In_ HWND hWnd, _Out_ LPTSTR lpString, _In_ int nMaxCount);
// HGLOBAL WINAPI LoadResource(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo);
// HLOCAL WINAPI LocalFree(_In_ HLOCAL hMem);
// LPVOID WINAPI LockResource(_In_ HGLOBAL hResData);
// void * memset(void *, int, size_t);
// int WINAPI MessageBoxA(_In_opt_ HWND hWnd, _In_opt_ LPCTSTR lpText, _In_opt_ LPCTSTR lpCaption, _In_ UINT uType);
// int printf(const char *restrict, ...);
// LONG WINAPI RegCloseKey(_In_ HKEY hKey);
// LONG WINAPI RegEnumKeyExA(_In_ HKEY hKey, _In_ DWORD dwIndex, _Out_ LPTSTR lpName, _Inout_ LPDWORD lpcName, _Reserved_ LPDWORD lpReserved, _Inout_ LPTSTR lpClass, _Inout_opt_ LPDWORD lpcClass, _Out_opt_ PFILETIME lpftLastWriteTime);
// LONG WINAPI RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCTSTR lpSubKey, _Reserved_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// LONG WINAPI RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCTSTR lpValueName, _Reserved_ LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, _Out_opt_ LPBYTE lpData, _Inout_opt_ LPDWORD lpcbData);
// BOOL WINAPI SetEnvironmentVariableA(_In_ LPCTSTR lpName, _In_opt_ LPCTSTR lpValue);
// LPTOP_LEVEL_EXCEPTION_FILTER WINAPI SetUnhandledExceptionFilter(_In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// HINSTANCE ShellExecuteA(_In_opt_ HWND hwnd, _In_opt_ LPCTSTR lpOperation, _In_ LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd);
// sighandler_t signal(int signum, sighandler_t handler);
// int stat(const char *restrict path, struct stat *restrict buf);
// char * strcat(char *restrict, const char *restrict);
// char * strchr(const char *, int);
// int strcmp(const char *, const char *);
// char * strcpy(char *restrict, const char *restrict);
// size_t strlen(const char *);
// char * strncat(char *restrict, const char *restrict, size_t);
// char * strncpy(char *restrict, const char *restrict, size_t);
// char * strrchr(const char *, int);
// char * strstr(const char *, const char *);
// DWORD WINAPI WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);
// int32_t strncmp(char * a1, char * a2, int32_t a3);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (mingw) (?.? (h))
// Detected functions: 37
// Decompiler release: v2.1.2 (2016-01-27)
// Decompilation date: 2016-07-20 17:51:52
